-- CustomGui.lua
-- Roblox GUI helper with Delta-executor friendly features, native Anti-AFK,
-- task manager (Stop All), per-game settings, teleport re-exec, and richer controls.
-- Usage: local Gui = require(path_to_CustomGui)

local CustomGui = {}

-- Services and shared locals
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService("HttpService")
local UIS = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local CoreGui = game:GetService("CoreGui")
local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")

-- Themes
local Themes = {
    Carbon = {
        bg = Color3.fromRGB(22,22,22),
        top = Color3.fromRGB(32,32,32),
        tab = Color3.fromRGB(35,35,35),
        tabActive = Color3.fromRGB(60,180,75),
        tabInactive = Color3.fromRGB(50,50,50),
        text = Color3.fromRGB(220,220,220),
        section = Color3.fromRGB(45,45,45),
        buttonOn = Color3.fromRGB(60,180,75),
        buttonOff = Color3.fromRGB(180,60,60),
        sliderBar = Color3.fromRGB(60,60,60),
        sliderThumb = Color3.fromRGB(100,100,255),
        dropdownBG = Color3.fromRGB(38,38,38),
        dropdownOpt = Color3.fromRGB(80,80,80),
    },
    Midnight = {
        bg = Color3.fromRGB(16,18,24),
        top = Color3.fromRGB(20,22,30),
        tab = Color3.fromRGB(24,26,34),
        tabActive = Color3.fromRGB(88,101,242),
        tabInactive = Color3.fromRGB(48,50,60),
        text = Color3.fromRGB(220,225,235),
        section = Color3.fromRGB(28,30,38),
        buttonOn = Color3.fromRGB(88,101,242),
        buttonOff = Color3.fromRGB(190,70,70),
        sliderBar = Color3.fromRGB(60,62,72),
        sliderThumb = Color3.fromRGB(126,137,255),
        dropdownBG = Color3.fromRGB(26,28,36),
        dropdownOpt = Color3.fromRGB(64,66,76),
    },
    Pastel = {
        bg = Color3.fromRGB(235,239,242),
        top = Color3.fromRGB(210,220,230),
        tab = Color3.fromRGB(215,225,235),
        tabActive = Color3.fromRGB(64,180,170),
        tabInactive = Color3.fromRGB(190,200,210),
        text = Color3.fromRGB(24,32,40),
        section = Color3.fromRGB(225,232,238),
        buttonOn = Color3.fromRGB(64,180,170),
        buttonOff = Color3.fromRGB(220,90,90),
        sliderBar = Color3.fromRGB(170,180,190),
        sliderThumb = Color3.fromRGB(64,160,200),
        dropdownBG = Color3.fromRGB(225,232,238),
        dropdownOpt = Color3.fromRGB(200,210,220),
    }
}

local function getThemeFor(inst)
    local sg = inst:FindFirstAncestorOfClass("ScreenGui")
    local name = sg and sg:GetAttribute("ThemeName") or "Carbon"
    return Themes[name] or Themes.Carbon, name or "Carbon"
end

-- Executor/Env utilities with safe fallbacks (Delta-friendly)
local Exec = {}
do
    local ok_identify, identify = pcall(function()
        return (identifyexecutor or identify_executor or getexecutorname)
    end)
    function Exec.identify()
        local name, ver
        if ok_identify and identify then
            local ok, a, b = pcall(function() return identify() end)
            if ok then
                if typeof(a) == "string" and typeof(b) == "string" then name, ver = a, b else name = tostring(a or "Unknown") end
            end
        end
        -- Common globals some executors expose
        if not name then
            if syn then name = "syn" end
            if KRNL_LOADED then name = "krnl" end
            if is_sirhurt_closure then name = "sirhurt" end
            if hookfunction and not name then name = "generic" end
        end
        return name or "unknown", ver
    end

    local function tryf(name)
        local ok, fn = pcall(function() return _G[name] or getfenv()[name] or _G[name] end)
        if ok and typeof(fn) == "function" then return fn end
        if syn and typeof(syn[name]) == "function" then return syn[name] end
        return nil
    end

    Exec.isfile = isfile or tryf("isfile")
    Exec.writefile = writefile or tryf("writefile")
    Exec.readfile = readfile or tryf("readfile")
    Exec.makefolder = makefolder or tryf("makefolder")
    Exec.isfolder = isfolder or tryf("isfolder")
    Exec.queue_on_teleport = queue_on_teleport or (syn and syn.queue_on_teleport) or tryf("queue_on_teleport")
    Exec.protect_gui = (syn and syn.protect_gui) or tryf("protect_gui")
    Exec.gethui = (gethui or get_hidden_ui or gethiddengui or stealth_ui) -- many aliases across executors
    Exec.setclipboard = setclipboard or (syn and syn.write_clipboard) or tryf("setclipboard")

    function Exec.notify(title, text, duration)
        pcall(function()
            StarterGui:SetCore("SendNotification", {Title = title or "CustomGui"; Text = text or ""; Duration = duration or 3})
        end)
    end

    -- Ensure folder exists (noop if FS not available)
    function Exec.ensure_folder(path)
        if not (Exec.isfolder and Exec.makefolder) then return end
        local ok = false
        pcall(function()
            if not Exec.isfolder(path) then Exec.makefolder(path) end
            ok = true
        end)
        return ok
    end
end

-- JSON helpers
local function json_encode(tbl)
    local ok, res = pcall(function() return HttpService:JSONEncode(tbl) end)
    return ok and res or "{}"
end
local function json_decode(str)
    if type(str) ~= "string" then return nil end
    local ok, res = pcall(function() return HttpService:JSONDecode(str) end)
    return ok and res or nil
end

-- UI parent selection (CoreGui/gethui preferred for exploit stability)
local function choose_ui_parent()
    -- Prefer hidden UI layer if provided by the executor
    if Exec.gethui and typeof(Exec.gethui) == "function" then
        local ok, ui = pcall(function() return Exec.gethui() end)
        if ok and typeof(ui) == "Instance" then return ui end
    end
    -- Try CoreGui (exploit)
    local ok = pcall(function() return CoreGui.Name end)
    if ok then return CoreGui end
    -- Fallback to PlayerGui (normal LocalScript context)
    local pg = LocalPlayer:FindFirstChildOfClass("PlayerGui") or LocalPlayer:WaitForChild("PlayerGui")
    return pg
end

function CustomGui:CreateWindow(props)
    props = props or {}
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = props.Name or "CustomWindow"
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    screenGui.DisplayOrder = 1_000_000 -- always on top
    screenGui:SetAttribute("ThemeName", props.Theme or "Carbon")
    screenGui:SetAttribute("Density", props.Density or "comfortable") -- comfortable | compact
    -- Protect and parent to executor UI if possible
    pcall(function() if Exec.protect_gui then Exec.protect_gui(screenGui) end end)
    screenGui.Parent = choose_ui_parent()

    -- Main frame
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0.7, 0, 0.7, 0)
    mainFrame.Position = UDim2.new(0.15, 0, 0.15, 0)
    local theme = getThemeFor(screenGui)
    mainFrame.BackgroundColor3 = theme.bg
    mainFrame.BorderSizePixel = 0
    mainFrame.BackgroundTransparency = 0.05
    mainFrame.Parent = screenGui
    mainFrame.ClipsDescendants = true
    mainFrame.AnchorPoint = Vector2.new(0,0)
    mainFrame.ZIndex = 1

    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 18)
    uiCorner.Parent = mainFrame

    -- Top bar (draggable, closable)
    local topBar = Instance.new("Frame")
    topBar.Name = "TopBar"
    local density = screenGui:GetAttribute("Density")
    local topH = (density == "compact") and 30 or 36
    topBar.Size = UDim2.new(1, 0, 0, topH)
    topBar.Position = UDim2.new(0, 0, 0, 0)
    topBar.BackgroundColor3 = theme.top
    topBar.Parent = mainFrame
    local topCorner = Instance.new("UICorner")
    topCorner.CornerRadius = UDim.new(0, 18)
    topCorner.Parent = topBar

    -- Drag shield (prevents accidental clicks on controls while dragging the window)
    local dragShield = Instance.new("Frame")
    dragShield.Name = "DragShield"
    dragShield.BackgroundTransparency = 1
    dragShield.Active = true
    dragShield.Visible = false
    dragShield.ZIndex = 999
    dragShield.Size = UDim2.new(1, 0, 1, 0)
    dragShield.Position = UDim2.new(0, 0, 0, 0)
    dragShield.Parent = mainFrame

    local title = Instance.new("TextLabel")
    title.Text = props.Name or "CustomWindow"
    title.Size = UDim2.new(1, -80, 1, 0)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.BackgroundTransparency = 1
    title.TextColor3 = theme.text
    title.Font = Enum.Font.GothamBold
    title.TextSize = 20
    title.Parent = topBar
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.TextWrapped = true

    local closeBtn = Instance.new("TextButton")
    closeBtn.Text = "❌"
    closeBtn.Size = UDim2.new(0, 36, 1, 0)
    closeBtn.Position = UDim2.new(1, -36, 0, 0)
    closeBtn.BackgroundTransparency = 1
    closeBtn.TextColor3 = Color3.fromRGB(255,0,0)
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.TextSize = 28
    closeBtn.Parent = topBar
    closeBtn.ZIndex = 2

    -- Minimize button
    local minimizeBtn = Instance.new("TextButton")
    minimizeBtn.Text = "_"
    minimizeBtn.Size = UDim2.new(0, 36, 1, 0)
    minimizeBtn.Position = UDim2.new(1, -72, 0, 0)
    minimizeBtn.BackgroundTransparency = 1
    minimizeBtn.TextColor3 = Color3.fromRGB(180,180,180)
    minimizeBtn.Font = Enum.Font.GothamBold
    minimizeBtn.TextSize = 24
    minimizeBtn.Parent = topBar
    minimizeBtn.ZIndex = 2

    -- Floating reopen button
    local reopenBtn = Instance.new("TextButton")
    reopenBtn.Text = "☰"
    reopenBtn.Size = UDim2.new(0, 44, 0, 44)
    reopenBtn.Position = UDim2.new(0, 14, 0, 14)
    reopenBtn.BackgroundColor3 = Color3.fromRGB(32,32,32)
    reopenBtn.TextColor3 = Color3.fromRGB(255,255,255)
    reopenBtn.Font = Enum.Font.GothamBold
    reopenBtn.TextSize = 28
    reopenBtn.Visible = false
    reopenBtn.Parent = screenGui
    reopenBtn.ZIndex = 100 -- keep on top of other UI
    local reopenCorner = Instance.new("UICorner")
    reopenCorner.CornerRadius = UDim.new(0, 14)
    reopenCorner.Parent = reopenBtn

    -- Ensure the reopen icon is at least partially visible when shown
    local function ensureReopenVisible()
        local scr = screenGui.AbsoluteSize
        local btn = reopenBtn.AbsoluteSize
        local pos = reopenBtn.AbsolutePosition
        
        print("ensureReopenVisible - Screen:", scr.X, scr.Y, "Button:", btn.X, btn.Y, "Position:", pos.X, pos.Y)
        
        -- Force to safe bounds if off-screen
        local nx = pos.X
        local ny = pos.Y
        local changed = false
        
        -- Keep icon fully on screen with some margin
        if pos.X < 0 then
            nx = 10
            changed = true
        elseif pos.X + btn.X > scr.X then
            nx = scr.X - btn.X - 10
            changed = true
        end
        
        if pos.Y < 0 then
            ny = 10
            changed = true
        elseif pos.Y + btn.Y > scr.Y then
            ny = scr.Y - btn.Y - 10
            changed = true
        end
        
        if changed then
            print("Correcting position from", pos.X, pos.Y, "to", nx, ny)
            reopenBtn.Position = UDim2.new(0, nx, 0, ny)
        end
    end

    -- Optional keybind to show/hide (RightShift default)
    local toggleKey = props.ToggleKey or Enum.KeyCode.RightShift
    UIS.InputBegan:Connect(function(input, gp)
        if gp then return end
        if input.KeyCode == toggleKey then
            if mainFrame.Visible then
                mainFrame.Visible = false
                reopenBtn.Visible = true
                dragShield.Visible = false
                ensureReopenVisible()
            else
                mainFrame.Visible = true
                reopenBtn.Visible = false
            end
        elseif input.KeyCode == Enum.KeyCode.F3 then
            -- F3: Emergency reset reopen icon position
            reopenBtn.Position = UDim2.new(0, 14, 0, 14)
            reopenBtn.Visible = true
            if windowObj._uiStore then
                windowObj._uiStore:Set("reopenPos", { ox = 14, oy = 14 })
            end
            Exec.notify("Icon Reset", "Reopen icon moved to top-left", 3)
            print("F3: Reset reopen icon to position (14, 14)")
        end
    end)

    -- window object exposed to caller
    local windowObj = {
        ScreenGui = screenGui,
        mainFrame = mainFrame,
        closeBtn = closeBtn,
        minimizeBtn = minimizeBtn,
        reopenBtn = reopenBtn,
        _closeCb = nil,
        _tasks = {},
        _stopAllFlag = false,
        _antiAFKConn = nil,
        _antiAFKEnabled = false,
        _antiAFKGui = nil,
        _antiAFKDot = nil,
        _store = nil,
    }

    function windowObj:SetCloseCallback(cb)
        self._closeCb = cb
    end

    function windowObj:Show()
        if self.ScreenGui then self.ScreenGui.Enabled = true end
        if self.mainFrame then self.mainFrame.Visible = true end
        if self.reopenBtn then self.reopenBtn.Visible = false end
    end

    function windowObj:Hide()
        if self.mainFrame then self.mainFrame.Visible = false end
        if self.ScreenGui then self.ScreenGui.Enabled = true end
        dragShield.Visible = false
        
        -- Force the reopen button to be visible and ensure it's on screen
        if self.reopenBtn then 
            self.reopenBtn.Visible = true
            ensureReopenVisible()
            -- Double-check visibility
            task.defer(function()
                if self.reopenBtn then
                    self.reopenBtn.Visible = true
                    print("Hide - Reopen icon position:", self.reopenBtn.AbsolutePosition)
                end
            end)
        end
        
        if self._closeCb then pcall(self._closeCb) end
    end

    function windowObj:Destroy()
        -- Ensure everything is stopped and cleaned
        self:StopAll()
        if self._closeCb then pcall(self._closeCb) end
        if self._cmdGui then pcall(function() self._cmdGui:Destroy() end); self._cmdGui = nil; self._cmdBox = nil end
        if self._antiAFKGui then pcall(function() self._antiAFKGui:Destroy() end); self._antiAFKGui = nil; self._antiAFKDot = nil end
        if self.ScreenGui then self.ScreenGui:Destroy() end
    end

    -- Task manager: register, run loop, and Stop All
    function windowObj:RegisterTask(id, ref)
        self._tasks[id] = ref
    end
    function windowObj:UnregisterTask(id)
        self._tasks[id] = nil
    end
    function windowObj:RunLoop(id, fn, interval)
        local alive = true
        local th = task.spawn(function()
            while alive and not self._stopAllFlag do
                local ok, err = pcall(fn)
                if not ok then warn("CustomGui loop error ["..tostring(id).."]:", err) end
                task.wait(interval or 0.5)
            end
        end)
        self:RegisterTask(id, {type="thread", thread = th, cancel = function() alive = false; pcall(task.cancel, th) end})
        return function() -- stop fn
            alive = false; self:UnregisterTask(id)
            pcall(task.cancel, th)
        end
    end
    function windowObj:StopAll()
        self._stopAllFlag = true
        for id, ref in pairs(self._tasks) do
            local t = typeof(ref)
            if t == "thread" then pcall(task.cancel, ref)
            elseif t == "RBXScriptConnection" then pcall(function() ref:Disconnect() end)
            elseif type(ref) == "table" and typeof(ref.thread) == "thread" then
                if type(ref.cancel) == "function" then pcall(ref.cancel) else pcall(task.cancel, ref.thread) end
            elseif type(ref) == "function" then pcall(ref) end
            self._tasks[id] = nil
        end
        -- Disable Anti-AFK if running
        self:EnableAntiAFK(false)
        -- Utilities cleanup: noclip, click TP
        if self._noclipConn then pcall(function() self._noclipConn:Disconnect() end); self._noclipConn = nil end
        if self._clickTPConn then pcall(function() self._clickTPConn:Disconnect() end); self._clickTPConn = nil end
        -- ESP cleanup: set flags false and call toggle to perform teardown
        if self._esp then self._esp.names=false; self._esp.highlight=false; self._esp.tracers=false end
        pcall(function() CustomGui:_toggleESP(self) end)
    end

    -- Native Anti-AFK with indicator dot (top-left)
    function windowObj:_ensureAFKGui()
        if self._antiAFKGui then return end
        local g = Instance.new("ScreenGui")
        g.Name = "AFKIndicator"
        g.IgnoreGuiInset = true
        g.ResetOnSpawn = false
        g.DisplayOrder = 1_000_000
        pcall(function() if Exec.protect_gui then Exec.protect_gui(g) end end)
        g.Parent = choose_ui_parent()
        local dot = Instance.new("Frame")
        dot.Name = "Dot"
        dot.Size = UDim2.new(0, 12, 0, 12)
        dot.Position = UDim2.new(0, 8, 0, 8)
        dot.BackgroundColor3 = Color3.fromRGB(0, 200, 0)
        dot.BorderSizePixel = 0
        dot.Parent = g
        local dcorner = Instance.new("UICorner")
        dcorner.CornerRadius = UDim.new(1, 0)
        dcorner.Parent = dot
        self._antiAFKGui = g
        self._antiAFKDot = dot
        dot.Visible = false
    end
    function windowObj:EnableAntiAFK(state)
        state = not not state
        self:_ensureAFKGui()
        if state and not self._antiAFKEnabled then
            local VirtualUser = game:GetService("VirtualUser")
            self._antiAFKConn = LocalPlayer.Idled:Connect(function()
                pcall(function()
                    VirtualUser:CaptureController()
                    VirtualUser:ClickButton2(Vector2.new())
                end)
            end)
            self._antiAFKEnabled = true
            if self._antiAFKDot then self._antiAFKDot.Visible = true end
            Exec.notify("Anti-AFK", "Enabled", 2)
        elseif (not state) and self._antiAFKEnabled then
            if self._antiAFKConn then pcall(function() self._antiAFKConn:Disconnect() end) end
            self._antiAFKConn = nil
            self._antiAFKEnabled = false
            if self._antiAFKDot then self._antiAFKDot.Visible = false end
            Exec.notify("Anti-AFK", "Disabled", 2)
        end
    end
    -- Optional default from props
    if props.AntiAFKDefault then windowObj:EnableAntiAFK(true) end

    -- Settings store (per-user/per-game paths if FS exists)
    function windowObj:CreateStore(name, opts)
        opts = opts or {}
        local userId = tostring(LocalPlayer.UserId or "0")
        local placeId = tostring(game.PlaceId or "0")
        local base = opts.base or "CustomGui"
        local perUser = (opts.perUser ~= false)
        local perGame = (opts.perGame ~= false)
        local parts = {base}
        if perUser then table.insert(parts, userId) end
        if perGame then table.insert(parts, placeId) end
        local folder = table.concat(parts, "/")
        local file = folder .. "/" .. (name or "settings") .. ".json"
        local function ensure()
            if not Exec.ensure_folder then return end
            local accum = {}
            for seg in string.gmatch(folder, "[^/]+") do
                table.insert(accum, seg)
                Exec.ensure_folder(table.concat(accum, "/"))
            end
        end
        ensure()
        local cache = {}
        local function save()
            if not Exec.writefile then return end
            local ok = pcall(function() Exec.writefile(file, json_encode(cache)) end)
            if not ok then warn("CustomGui: failed to write settings "..file) end
        end
        local function load()
            if not (Exec.isfile and Exec.readfile) then return end
            local ok, str = pcall(function()
                if Exec.isfile(file) then return Exec.readfile(file) end
            end)
            if ok and type(str) == "string" then
                local got = json_decode(str)
                if type(got) == "table" then cache = got end
            end
        end
        load()
        local store = {}
        function store:Get(k, default)
            local v = cache[k]
            if v == nil then return default end
            return v
        end
        function store:Set(k, v)
            cache[k] = v
            save()
        end
        function store:All() return cache end
        function store:Save() save() end
        function store:Load() load() end
        self._store = store
        return store
    end

    -- Draggable reopen button with persisted position (initialized after CreateStore is available)
    do
        windowObj._uiStore = windowObj:CreateStore("ui")
        -- Apply saved window position (pixels) if exists
        local function applySavedWindowPos()
            local saved = windowObj._uiStore and windowObj._uiStore:Get("windowPos")
            if type(saved) == "table" then
                if typeof(saved.ox) == "number" and typeof(saved.oy) == "number" then
                    mainFrame.Position = UDim2.new(0, saved.ox, 0, saved.oy)
                elseif typeof(saved.sx) == "number" and typeof(saved.sy) == "number" then
                    -- Backward compatibility for normalized saved values
                    local scr = screenGui.AbsoluteSize
                    local fr = mainFrame.AbsoluteSize
                    local x = saved.sx * math.max(0, scr.X - fr.X)
                    local y = saved.sy * math.max(0, scr.Y - fr.Y)
                    mainFrame.Position = UDim2.new(0, math.floor(x + 0.5), 0, math.floor(y + 0.5))
                end
            end
        end
        task.defer(applySavedWindowPos)
        screenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(applySavedWindowPos)
        local function applySavedReopenPos()
            local saved = windowObj._uiStore and windowObj._uiStore:Get("reopenPos")
            local positioned = false
            
            if type(saved) == "table" then
                if typeof(saved.ox) == "number" and typeof(saved.oy) == "number" then
                    -- Validate saved position is reasonable
                    local scr = screenGui.AbsoluteSize
                    if saved.ox >= -50 and saved.ox < scr.X + 50 and saved.oy >= -50 and saved.oy < scr.Y + 50 then
                        reopenBtn.Position = UDim2.new(0, saved.ox, 0, saved.oy)
                        positioned = true
                        print("Loaded saved position:", saved.ox, saved.oy)
                    else
                        print("Saved position invalid:", saved.ox, saved.oy, "Screen size:", scr.X, scr.Y)
                    end
                elseif typeof(saved.sx) == "number" and typeof(saved.sy) == "number" then
                    -- Backward compatible with older normalized positions
                    local scr = screenGui.AbsoluteSize
                    local btn = reopenBtn.AbsoluteSize
                    local x = saved.sx * math.max(0, scr.X - btn.X)
                    local y = saved.sy * math.max(0, scr.Y - btn.Y)
                    if x >= 0 and x < scr.X and y >= 0 and y < scr.Y then
                        reopenBtn.Position = UDim2.new(0, math.floor(x + 0.5), 0, math.floor(y + 0.5))
                        positioned = true
                        print("Loaded normalized position:", x, y)
                    else
                        print("Normalized position invalid:", x, y)
                    end
                end
            end
            
            -- If no saved position or position seems invalid, use default
            if not positioned then
                reopenBtn.Position = UDim2.new(0, 14, 0, 14)
                print("Reset reopen icon to default position (14, 14)")
            end
            
            ensureReopenVisible()
            
            -- Failsafe: if still not visible after positioning, force to default
            task.defer(function()
                local pos = reopenBtn.AbsolutePosition
                local scr = screenGui.AbsoluteSize
                local btn = reopenBtn.AbsoluteSize
                
                if pos.X + btn.X <= 0 or pos.Y + btn.Y <= 0 or pos.X >= scr.X or pos.Y >= scr.Y then
                    print("Icon was completely off-screen, forcing to default position")
                    reopenBtn.Position = UDim2.new(0, 14, 0, 14)
                    if windowObj._uiStore then
                        windowObj._uiStore:Set("reopenPos", { ox = 14, oy = 14 })
                    end
                end
            end)
        end
        task.defer(applySavedReopenPos)
        screenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(applySavedReopenPos)

        -- Simple reopen icon drag system (same as main window)
        local rDragging, rPending, rDragInput, rDragStart, rStartPos
        local rMovedMag = 0
        local REOPEN_DRAG_SLOP = 8 -- pixels of movement before we consider it a drag
        
        local function saveReopenPos()
            -- Make sure store exists before using it
            if not windowObj._uiStore then 
                windowObj._uiStore = windowObj:CreateStore("ui")
            end
            
            -- Ensure icon is at least partially visible before saving
            ensureReopenVisible()
            
            local pos = reopenBtn.AbsolutePosition
            print("Saving reopen position:", pos.X, pos.Y)
            
            -- Save the corrected position
            if windowObj._uiStore then
                windowObj._uiStore:Set("reopenPos", { ox = pos.X, oy = pos.Y })
            end
        end
        
        local function beginReopenDrag(input)
            rDragging = true
            rPending = false
            rDragStart = input.Position
            rStartPos = reopenBtn.AbsolutePosition
            rMovedMag = 0
            
            print("Begin drag - Start position:", rStartPos)
            
            -- Ensure icon is visible when starting drag
            reopenBtn.Visible = true
            
            if input.UserInputType == Enum.UserInputType.Touch then
                rDragInput = input
            else
                rDragInput = nil
            end
        end
        
        local function endReopenDrag()
            if rDragging or rPending then
                local wasDragging = rDragging
                rDragging = false
                rPending = false
                if wasDragging then
                    print("Ending drag - Icon position before save:", reopenBtn.AbsolutePosition)
                    
                    -- Force visibility and save position
                    reopenBtn.Visible = true
                    saveReopenPos()
                    
                    print("Ending drag - Icon position after save:", reopenBtn.AbsolutePosition, "Visible:", reopenBtn.Visible)
                else
                    -- Was just a click - open the main window
                    mainFrame.Visible = true
                    reopenBtn.Visible = false
                    dragShield.Visible = false
                end
            end
        end
        
        local function updateReopenDrag(input)
            if not rDragging then
                if not rPending then return end
                local delta = Vector2.new(input.Position.X - rDragStart.X, input.Position.Y - rDragStart.Y)
                rMovedMag = math.max(rMovedMag, delta.Magnitude)
                if rMovedMag >= REOPEN_DRAG_SLOP then
                    beginReopenDrag(input)
                else
                    return
                end
            end
            
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                local delta = Vector2.new(input.Position.X - rDragStart.X, input.Position.Y - rDragStart.Y)
                rMovedMag = math.max(rMovedMag, delta.Magnitude)
                local newAbs = Vector2.new(rStartPos.X + delta.X, rStartPos.Y + delta.Y)
                reopenBtn.Position = UDim2.new(0, newAbs.X, 0, newAbs.Y)
                
                -- Ensure visibility during drag
                reopenBtn.Visible = true
                
            elseif input.UserInputType == Enum.UserInputType.Touch then
                if (rDragInput == nil) or (input == rDragInput) then
                    local delta = input.Position - rDragStart
                    rMovedMag = math.max(rMovedMag, delta.Magnitude)
                    local newAbs = Vector2.new(rStartPos.X + delta.X, rStartPos.Y + delta.Y)
                    reopenBtn.Position = UDim2.new(0, newAbs.X, 0, newAbs.Y)
                    
                    -- Ensure visibility during drag
                    reopenBtn.Visible = true
                end
            end
        end
        
        reopenBtn.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                rPending = true
                rDragging = false
                rDragStart = input.Position
                rStartPos = reopenBtn.AbsolutePosition
                rMovedMag = 0
                if input.UserInputType == Enum.UserInputType.Touch then 
                    rDragInput = input 
                else 
                    rDragInput = nil 
                end
            end
        end)
        
        reopenBtn.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                updateReopenDrag(input)
            end
        end)
        
        UIS.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                updateReopenDrag(input)
            end
        end)
        
        reopenBtn.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                endReopenDrag()
            end
        end)
        
        UIS.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                endReopenDrag()
            end
        end)
    end

    -- Teleport re-exec helper
    function windowObj:QueueOnTeleport(luaSource)
        if not Exec.queue_on_teleport then return false end
        local ok = pcall(function() Exec.queue_on_teleport(luaSource) end)
        return ok
    end

    closeBtn.MouseButton1Click:Connect(function()
        -- X should completely stop and destroy the GUI
        windowObj:StopAll()
        windowObj:Destroy()
    end)
    minimizeBtn.MouseButton1Click:Connect(function()
        mainFrame.Visible = false
        dragShield.Visible = false
        
        -- Force the reopen button to be visible and ensure it's on screen
        reopenBtn.Visible = true
        
        -- Force icon to a safe visible position
        reopenBtn.Position = UDim2.new(0, 14, 0, 14)
        
        -- Wait a frame for position to update, then check
        task.defer(function()
            local pos = reopenBtn.AbsolutePosition
            local scr = screenGui.AbsoluteSize
            local btn = reopenBtn.AbsoluteSize
            
            print("After minimize - Screen size:", scr.X, scr.Y, "Icon size:", btn.X, btn.Y, "Icon pos:", pos.X, pos.Y)
            
            -- If still off-screen, force it to a different position
            if pos.Y < 0 or pos.X < 0 or pos.X >= scr.X or pos.Y >= scr.Y then
                print("Still off-screen after reset, trying alternative position")
                reopenBtn.Position = UDim2.new(0, 50, 0, 50)
            end
            
            -- Save the corrected position
            if windowObj._uiStore then
                local finalPos = reopenBtn.AbsolutePosition
                windowObj._uiStore:Set("reopenPos", { ox = finalPos.X, oy = finalPos.Y })
                print("Saved corrected position:", finalPos.X, finalPos.Y)
            end
        end)
        
        print("Minimized - Reopen icon position:", reopenBtn.AbsolutePosition, "Visible:", reopenBtn.Visible)
    end)
    -- MouseButton1Click is handled in InputEnded above to avoid triggering when dragging

    -- Dragging logic: instant threshold-based drag from anywhere
    local wDragging, wPending, wDragInput, wDragStart, wStartPos
    local wMovedMag = 0
    local DRAG_SLOP = 6 -- pixels of movement before we consider it a drag
    local function saveWindowPos()
        if not windowObj._uiStore then return end
        local pos = mainFrame.AbsolutePosition
        windowObj._uiStore:Set("windowPos", { ox = pos.X, oy = pos.Y })
    end
    local function beginWindowDrag(input)
        wDragging = true
        wPending = false
        wDragStart = input.Position
        wStartPos = mainFrame.AbsolutePosition
        wMovedMag = 0
        dragShield.Visible = true
        if input.UserInputType == Enum.UserInputType.Touch then
            wDragInput = input
        else
            wDragInput = nil
        end
    end
    local function endWindowDrag()
        if wDragging or wPending then
            wDragging = false
            wPending = false
            dragShield.Visible = false
            saveWindowPos()
        end
    end
    local function updateDrag(input)
        if not wDragging then
            if not wPending then return end
            local delta = Vector2.new(input.Position.X - wDragStart.X, input.Position.Y - wDragStart.Y)
            wMovedMag = math.max(wMovedMag, delta.Magnitude)
            if wMovedMag >= DRAG_SLOP then
                beginWindowDrag(input)
            else
                return
            end
        end
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = Vector2.new(input.Position.X - wDragStart.X, input.Position.Y - wDragStart.Y)
            wMovedMag = math.max(wMovedMag, delta.Magnitude)
            local newAbs = Vector2.new(wStartPos.X + delta.X, wStartPos.Y + delta.Y)
            mainFrame.Position = UDim2.new(0, newAbs.X, 0, newAbs.Y)
        elseif input.UserInputType == Enum.UserInputType.Touch then
            if (wDragInput == nil) or (input == wDragInput) then
                local delta = input.Position - wDragStart
                wMovedMag = math.max(wMovedMag, delta.Magnitude)
                local newAbs = Vector2.new(wStartPos.X + delta.X, wStartPos.Y + delta.Y)
                mainFrame.Position = UDim2.new(0, newAbs.X, 0, newAbs.Y)
            end
        end
    end
    mainFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            wPending = true
            wDragging = false
            wDragStart = input.Position
            wStartPos = mainFrame.AbsolutePosition
            wMovedMag = 0
            if input.UserInputType == Enum.UserInputType.Touch then wDragInput = input else wDragInput = nil end
        end
    end)
    mainFrame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            updateDrag(input)
        end
    end)
    UIS.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            updateDrag(input)
        end
    end)
    mainFrame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            endWindowDrag()
        end
    end)
    UIS.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            endWindowDrag()
        end
    end)

    -- Tab bar
    local tabBar = Instance.new("Frame")
    tabBar.Name = "TabBar"
    local tabH = (density == "compact") and 32 or 38
    tabBar.Size = UDim2.new(1, 0, 0, tabH)
    tabBar.Position = UDim2.new(0, 0, 0, topH + 4)
    tabBar.BackgroundColor3 = theme.tab
    tabBar.Parent = mainFrame
    local tabCorner = Instance.new("UICorner")
    tabCorner.CornerRadius = UDim.new(0, 12)
    tabCorner.Parent = tabBar

    local tabLayout = Instance.new("UIListLayout")
    tabLayout.Parent = tabBar
    tabLayout.FillDirection = Enum.FillDirection.Horizontal
    tabLayout.Padding = UDim.new(0, 8)
    tabLayout.SortOrder = Enum.SortOrder.LayoutOrder

    -- Tabs storage
    local tabs = {}
    local tabContents = {}
    local activeTab = nil

    function CustomGui:MakeTab(tabProps)
        local tabBtn = Instance.new("TextButton")
        tabBtn.Text = tabProps.Name or "Tab"
    tabBtn.Size = UDim2.new(0, (density == "compact") and 100 or 120, 1, (density == "compact") and -6 or -8)
        tabBtn.BackgroundColor3 = theme.tabInactive
        tabBtn.TextColor3 = theme.text
        tabBtn.Font = Enum.Font.GothamBold
    tabBtn.TextSize = (density == "compact") and 16 or 18
        tabBtn.Parent = tabBar
        tabBtn.AutoButtonColor = true
        local btnCorner = Instance.new("UICorner")
        btnCorner.CornerRadius = UDim.new(0, 8)
        btnCorner.Parent = tabBtn

    local tabContent = Instance.new("ScrollingFrame")
        tabContent.Name = tabProps.Name .. "_Content"
    local padTop = topH + tabH + 8
    tabContent.Size = UDim2.new(1, -8, 1, -padTop - 8)
    tabContent.Position = UDim2.new(0, 4, 0, padTop)
        tabContent.CanvasSize = UDim2.new(0, 0, 0, 800)
    tabContent.ScrollBarThickness = (density == "compact") and 8 or 10
        tabContent.BackgroundTransparency = 1
        tabContent.Parent = mainFrame
        tabContent.AutomaticCanvasSize = Enum.AutomaticSize.Y
        tabContent.ScrollingDirection = Enum.ScrollingDirection.Y
        tabContent.Visible = false

        local layout = Instance.new("UIListLayout")
        layout.Parent = tabContent
    layout.Padding = UDim.new(0, (density == "compact") and 10 or 18)
        layout.SortOrder = Enum.SortOrder.LayoutOrder

        tabs[#tabs+1] = tabBtn
        tabContents[#tabContents+1] = tabContent

        tabBtn.MouseButton1Click:Connect(function()
            for i, t in ipairs(tabContents) do
                t.Visible = false
                tabs[i].BackgroundColor3 = theme.tabInactive
            end
            tabContent.Visible = true
            tabBtn.BackgroundColor3 = theme.tabActive
            activeTab = tabContent
        end)

        if #tabs == 1 then
            tabBtn.BackgroundColor3 = theme.tabActive
            tabContent.Visible = true
            activeTab = tabContent
        end

        return tabContent
    end

    function windowObj:MakeTab(tabProps)
        return CustomGui:MakeTab(tabProps)
    end
    return windowObj
end

function CustomGui:CreateTab(parent, props)
    -- Just return parent (scroll) for simplicity, all controls go in scroll
    return parent
end

function CustomGui:AddSection(parent, props)
    local section = Instance.new("Frame")
    local theme = getThemeFor(parent)
    local sg = parent:FindFirstAncestorOfClass("ScreenGui")
    local density = sg and sg:GetAttribute("Density") or "comfortable"
    section.Size = UDim2.new(0.98, 0, 0, (density == "compact") and 38 or 44)
    section.BackgroundColor3 = theme.section
    section.BackgroundTransparency = 0.15
    section.Parent = parent
    section.LayoutOrder = parent:GetChildren() and #parent:GetChildren() or 1
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 12)
    uiCorner.Parent = section
    local label = Instance.new("TextLabel")
    label.Text = props.Name or "Section"
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = theme.text
    label.Font = Enum.Font.GothamBold
    label.TextSize = (density == "compact") and 20 or 24
    label.Parent = section
    label.AnchorPoint = Vector2.new(0.5,0.5)
    label.Position = UDim2.new(0.5,0,0.5,0)
    return section
end

function CustomGui:AddLabel(parent, text)
    local label = Instance.new("TextLabel")
    label.Text = text
    local sg = parent:FindFirstAncestorOfClass("ScreenGui")
    local density = sg and sg:GetAttribute("Density") or "comfortable"
    label.Size = UDim2.new(0.98, 0, 0, (density == "compact") and 22 or 28)
    label.BackgroundTransparency = 1
    local theme = getThemeFor(parent)
    label.TextColor3 = theme.text
    label.Font = Enum.Font.Gotham
    label.TextSize = 18
    label.Parent = parent
    label.LayoutOrder = parent:GetChildren() and #parent:GetChildren() or 1
    return label
end

-- Collapsible grouped section (top-level definition)
function CustomGui:AddGroup(parent, props)
    local theme = getThemeFor(parent)
    local sg = parent:FindFirstAncestorOfClass("ScreenGui")
    local density = sg and sg:GetAttribute("Density") or "comfortable"
    local group = Instance.new("Frame")
    group.Name = (props.Name or "Group") .. "_Group"
    group.Size = UDim2.new(0.98, 0, 0, 40)
    group.AutomaticSize = Enum.AutomaticSize.Y
    group.BackgroundColor3 = theme.section
    group.BackgroundTransparency = 0.1
    group.Parent = parent
    group.LayoutOrder = parent:GetChildren() and #parent:GetChildren() or 1
    local corner = Instance.new("UICorner"); corner.CornerRadius = UDim.new(0, 10); corner.Parent = group
    local header = Instance.new("TextButton")
    header.Size = UDim2.new(1, -8, 0, (density == "compact") and 30 or 36)
    header.Position = UDim2.new(0, 4, 0, 2)
    header.BackgroundTransparency = 1
    header.Text = (props.Name or "Group") .. "  ▾"
    header.TextXAlignment = Enum.TextXAlignment.Left
    header.TextColor3 = theme.text
    header.Font = Enum.Font.GothamBold
    header.TextSize = (density == "compact") and 18 or 20
    header.Parent = group
    local content = Instance.new("Frame")
    content.Name = "Content"
    content.Size = UDim2.new(1, -8, 0, 0)
    content.AutomaticSize = Enum.AutomaticSize.Y
    content.Position = UDim2.new(0, 4, 0, (density == "compact") and 32 or 38)
    content.BackgroundTransparency = 1
    content.Parent = group
    local list = Instance.new("UIListLayout")
    list.Parent = content
    list.Padding = UDim.new(0, (density == "compact") and 6 or 10)
    list.SortOrder = Enum.SortOrder.LayoutOrder
    local collapsed = false
    header.MouseButton1Click:Connect(function()
        collapsed = not collapsed
        header.Text = (props.Name or "Group") .. (collapsed and "  ▸" or "  ▾")
        content.Visible = not collapsed
    end)
    function group:GetContent() return content end
    return group
end

function CustomGui:AddButton(parent, props)
    local theme = getThemeFor(parent)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0.98, 0, 0, 36)
    btn.Text = props.Name or "Button"
    btn.BackgroundColor3 = theme.tabInactive
    btn.TextColor3 = theme.text
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 18
    btn.Parent = parent
    btn.LayoutOrder = parent:GetChildren() and #parent:GetChildren() or 1
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = btn
    btn.MouseButton1Click:Connect(function()
        if props.Callback then props.Callback() end
    end)
    return btn
end

function CustomGui:AddToggle(parent, props)
    local button = Instance.new("TextButton")
    button.Text = props.Name or "Toggle"
    button.Size = UDim2.new(0.98, 0, 0, 36)
    local theme = getThemeFor(parent)
    button.BackgroundColor3 = theme.buttonOn
    button.TextColor3 = Color3.fromRGB(255,255,255)
    button.Font = Enum.Font.GothamBold
    button.TextSize = 20
    button.Parent = parent
    button.LayoutOrder = parent:GetChildren() and #parent:GetChildren() or 1
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = button
    local state = props.Default or false
    -- store state as attribute for observability (no custom members on Instance)
    pcall(function() button:SetAttribute("CG_State", state) end)
    -- Immediately call the callback with the default value and set visuals
    button.BackgroundColor3 = state and theme.buttonOn or theme.buttonOff
    if props.Callback then props.Callback(state) end
    button.MouseButton1Click:Connect(function()
        state = not state
        pcall(function() button:SetAttribute("CG_State", state) end)
        button.BackgroundColor3 = state and theme.buttonOn or theme.buttonOff
        if props.Callback then props.Callback(state) end
    end)
    return button
end

function CustomGui:AddSlider(parent, props)
    local sliderFrame = Instance.new("Frame")
    sliderFrame.Size = UDim2.new(0.98, 0, 0, 44)
    sliderFrame.BackgroundTransparency = 1
    sliderFrame.Parent = parent
    sliderFrame.LayoutOrder = parent:GetChildren() and #parent:GetChildren() or 1

    local label = Instance.new("TextLabel")
    label.Text = props.Name .. ": " .. tostring(props.Default or props.Min)
    local sg = parent:FindFirstAncestorOfClass("ScreenGui")
    local density = sg and sg:GetAttribute("Density") or "comfortable"
    label.Size = UDim2.new(1, 0, 0, (density == "compact") and 16 or 18)
    label.Position = UDim2.new(0, 0, 0, 0)
    label.BackgroundTransparency = 1
    local theme = getThemeFor(parent)
    label.TextColor3 = theme.text
    label.Font = Enum.Font.Gotham
    label.TextSize = 16
    label.Parent = sliderFrame

    local bar = Instance.new("Frame")
    bar.Size = UDim2.new(0.92, 0, 0, (density == "compact") and 6 or 8)
    bar.Position = UDim2.new(0.04, 0, 0, (density == "compact") and 22 or 26)
    bar.BackgroundColor3 = theme.sliderBar
    bar.Parent = sliderFrame
    local barCorner = Instance.new("UICorner")
    barCorner.CornerRadius = UDim.new(0, 4)
    barCorner.Parent = bar

    local thumb = Instance.new("Frame")
    thumb.Size = UDim2.new(0, (density == "compact") and 14 or 18, 0, (density == "compact") and 14 or 18)
    thumb.Position = UDim2.new(0, 0, 0, (density == "compact") and -4 or -5)
    thumb.BackgroundColor3 = theme.sliderThumb
    thumb.Parent = bar
    local thumbCorner = Instance.new("UICorner")
    thumbCorner.CornerRadius = UDim.new(0, 9)
    thumbCorner.Parent = thumb

    local value = props.Default or props.Min
    local min, max = props.Min, props.Max
    local dragging = false
    local changedCb = nil

    local function setValue(newValue)
        value = math.clamp(newValue, min, max)
        local percent = (value - min) / (max - min)
        thumb.Position = UDim2.new(percent, -9, 0, -5)
        label.Text = props.Name .. ": " .. string.format("%.2f", value)
        if props.Callback then props.Callback(value) end
        if changedCb then pcall(changedCb, value) end
    end
    setValue(value)

    thumb.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
        end
    end)
    thumb.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)
    bar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            local x = input.Position.X - bar.AbsolutePosition.X
            local percent = math.clamp(x / bar.AbsoluteSize.X, 0, 1)
            setValue(min + percent * (max - min))
        end
    end)
    game:GetService("UserInputService").InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local x = input.Position.X - bar.AbsolutePosition.X
            local percent = math.clamp(x / bar.AbsoluteSize.X, 0, 1)
            setValue(min + percent * (max - min))
        end
    end)
    -- expose current value as attribute for simple external reads
    pcall(function() sliderFrame:SetAttribute("CG_Value", value) end)
    -- remove custom methods on Instance to avoid 'not a valid member'
    return sliderFrame
end

function CustomGui:AddMultiDropdown(parent, props)
    local frame = Instance.new("Frame")
    local theme = getThemeFor(parent)
    local sg = parent:FindFirstAncestorOfClass("ScreenGui")
    local density = sg and sg:GetAttribute("Density") or "comfortable"
    frame.Size = UDim2.new(0.98, 0, 0, 0)
    frame.AutomaticSize = Enum.AutomaticSize.Y
    frame.BackgroundColor3 = theme.dropdownBG
    frame.BackgroundTransparency = 0.18
    frame.ClipsDescendants = true
    frame.Parent = parent
    frame.LayoutOrder = parent:GetChildren() and #parent:GetChildren() or 1
    local uiCorner = Instance.new("UICorner"); uiCorner.CornerRadius = UDim.new(0, 8); uiCorner.Parent = frame
    local pad = Instance.new("UIPadding"); pad.PaddingLeft = UDim.new(0,4); pad.PaddingRight = UDim.new(0,4); pad.PaddingTop = UDim.new(0,6); pad.PaddingBottom = UDim.new(0,6); pad.Parent = frame
    local stack = Instance.new("UIListLayout"); stack.Parent = frame; stack.Padding = UDim.new(0, (density=="compact") and 4 or 6); stack.SortOrder = Enum.SortOrder.LayoutOrder

    local header = Instance.new("TextButton")
    header.Text = (props.Name or "Dropdown") .. "  ▾"
    header.Size = UDim2.new(1, 0, 0, (density == "compact") and 26 or 30)
    header.BackgroundTransparency = 1
    header.TextColor3 = theme.text
    header.Font = Enum.Font.GothamBold
    header.TextSize = (density == "compact") and 16 or 18
    header.Parent = frame

    local selected = {}
    local defaultsSet = false
    if type(props.Default) == "table" then for _, v in ipairs(props.Default) do selected[#selected+1] = v end; defaultsSet = true end

    local panel = Instance.new("Frame")
    panel.Name = "Options"
    panel.Size = UDim2.new(1, 0, 0, 0)
    panel.AutomaticSize = Enum.AutomaticSize.Y
    panel.BackgroundTransparency = 1
    panel.Visible = false
    panel.Parent = frame
    local list = Instance.new("UIListLayout"); list.Parent = panel; list.Padding = UDim.new(0, (density == "compact") and 4 or 6); list.SortOrder = Enum.SortOrder.LayoutOrder

    header.MouseButton1Click:Connect(function()
        panel.Visible = not panel.Visible
        header.Text = (props.Name or "Dropdown") .. (panel.Visible and "  ▾" or "  ▸")
    end)

    for _, option in ipairs(props.Options or {}) do
        local optBtn = Instance.new("TextButton")
        optBtn.Text = tostring(option)
        optBtn.Size = UDim2.new(1, -8, 0, (density == "compact") and 24 or 28)
        optBtn.BackgroundColor3 = theme.dropdownOpt
        optBtn.TextColor3 = theme.text
        optBtn.Font = Enum.Font.Gotham
        optBtn.TextSize = (density == "compact") and 14 or 16
        optBtn.Parent = panel
        local btnCorner = Instance.new("UICorner"); btnCorner.CornerRadius = UDim.new(0, 6); btnCorner.Parent = optBtn
        if defaultsSet and table.find(selected, option) then optBtn.BackgroundColor3 = theme.buttonOn end
        optBtn.MouseButton1Click:Connect(function()
            if table.find(selected, option) then
                for idx, val in ipairs(selected) do if val == option then table.remove(selected, idx) break end end
                optBtn.BackgroundColor3 = theme.dropdownOpt
            else
                table.insert(selected, option)
                optBtn.BackgroundColor3 = theme.buttonOn
            end
            if props.Callback then props.Callback(selected) end
        end)
    end

    if defaultsSet and props.Callback then props.Callback(table.clone(selected)) end
    return frame
end

-- Single-select dropdown (library-agnostic)
function CustomGui:AddDropdown(parent, props)
    local frame = Instance.new("Frame")
    local theme = getThemeFor(parent)
    local sg = parent:FindFirstAncestorOfClass("ScreenGui")
    local density = sg and sg:GetAttribute("Density") or "comfortable"
    frame.Size = UDim2.new(0.98, 0, 0, 0)
    frame.AutomaticSize = Enum.AutomaticSize.Y
    frame.BackgroundColor3 = theme.dropdownBG
    frame.BackgroundTransparency = 0.18
    frame.ClipsDescendants = true
    frame.Parent = parent
    frame.LayoutOrder = parent:GetChildren() and #parent:GetChildren() or 1
    local uiCorner = Instance.new("UICorner"); uiCorner.CornerRadius = UDim.new(0, 8); uiCorner.Parent = frame
    local pad = Instance.new("UIPadding"); pad.PaddingLeft = UDim.new(0,4); pad.PaddingRight = UDim.new(0,4); pad.PaddingTop = UDim.new(0,6); pad.PaddingBottom = UDim.new(0,6); pad.Parent = frame
    local stack = Instance.new("UIListLayout"); stack.Parent = frame; stack.Padding = UDim.new(0, (density=="compact") and 4 or 6); stack.SortOrder = Enum.SortOrder.LayoutOrder

    local header = Instance.new("TextButton")
    header.Text = (props.Name or "Dropdown") .. "  ▾"
    header.Size = UDim2.new(1, 0, 0, (density == "compact") and 26 or 30)
    header.BackgroundTransparency = 1
    header.TextColor3 = theme.text
    header.Font = Enum.Font.GothamBold
    header.TextSize = (density == "compact") and 16 or 18
    header.Parent = frame

    local value = props.Default
    local panel = Instance.new("Frame")
    panel.Name = "Options"
    panel.Size = UDim2.new(1, 0, 0, 0)
    panel.AutomaticSize = Enum.AutomaticSize.Y
    panel.BackgroundTransparency = 1
    panel.Visible = false
    panel.Parent = frame
    local list = Instance.new("UIListLayout"); list.Parent = panel; list.Padding = UDim.new(0, (density == "compact") and 4 or 6); list.SortOrder = Enum.SortOrder.LayoutOrder

    header.MouseButton1Click:Connect(function()
        panel.Visible = not panel.Visible
        header.Text = (props.Name or "Dropdown") .. (panel.Visible and "  ▾" or "  ▸")
    end)

    for _, option in ipairs(props.Options or {}) do
        local optBtn = Instance.new("TextButton")
        optBtn.Text = tostring(option)
        optBtn.Size = UDim2.new(1, -8, 0, (density == "compact") and 24 or 28)
        optBtn.BackgroundColor3 = theme.dropdownOpt
        optBtn.TextColor3 = theme.text
        optBtn.Font = Enum.Font.Gotham
        optBtn.TextSize = (density == "compact") and 14 or 16
        optBtn.Parent = panel
        local btnCorner = Instance.new("UICorner"); btnCorner.CornerRadius = UDim.new(0, 6); btnCorner.Parent = optBtn
        if value == option then optBtn.BackgroundColor3 = theme.buttonOn end
        optBtn.MouseButton1Click:Connect(function()
            value = option
            for _, c in ipairs(panel:GetChildren()) do if c:IsA("TextButton") then c.BackgroundColor3 = theme.dropdownOpt end end
            optBtn.BackgroundColor3 = theme.buttonOn
            if props.Callback then props.Callback(value) end
            pcall(function() frame:SetAttribute("CG_Value", value) end)
            panel.Visible = false
            header.Text = (props.Name or "Dropdown") .. "  ▸"
        end)
    end

    pcall(function() frame:SetAttribute("CG_Value", value) end)
    if props.Default ~= nil and props.Callback then props.Callback(value) end
    return frame
end

-- Window helpers: theme switch, utilities, keybinds, command palette, ESP, noclip, click TP
do
    function CustomGui:_applyThemeToWindow(win, themeName)
        local theme = Themes[themeName] or Themes.Carbon
        local sg = win.ScreenGui
        if not sg then return end
        sg:SetAttribute("ThemeName", themeName)
        -- top-level frames
        if win.mainFrame then win.mainFrame.BackgroundColor3 = theme.bg end
        local topBar = win.mainFrame and win.mainFrame:FindFirstChild("TopBar")
        if topBar then topBar.BackgroundColor3 = theme.top end
        local tabBar = win.mainFrame and win.mainFrame:FindFirstChild("TabBar")
        if tabBar then tabBar.BackgroundColor3 = theme.tab end
        -- recolor tab buttons
        if tabBar then
            for _, child in ipairs(tabBar:GetChildren()) do
                if child:IsA("TextButton") then
                    child.TextColor3 = theme.text
                    -- keep active visually if its content visible
                    child.BackgroundColor3 = theme.tabInactive
                end
            end
        end
        -- recolor common controls in content
        for _, fr in ipairs(win.mainFrame and win.mainFrame:GetChildren() or {}) do
            if fr:IsA("ScrollingFrame") then
                for _, c in ipairs(fr:GetChildren()) do
                    if c:IsA("Frame") then
                        if c.Name == "Section" or c:FindFirstChildOfClass("TextLabel") then
                            pcall(function() c.BackgroundColor3 = theme.section end)
                        end
                    elseif c:IsA("TextButton") then
                        pcall(function() c.TextColor3 = theme.text end)
                    elseif c:IsA("TextLabel") then
                        pcall(function() c.TextColor3 = theme.text end)
                    end
                end
            end
        end
    end

    function CustomGui:_ensureKeybindLoop(win)
        if win._keybindConn then return end
        win._keybinds = win._keybinds or {}
        win._keybindConn = UIS.InputBegan:Connect(function(input, gp)
            if gp then return end
            if input.UserInputType == Enum.UserInputType.Keyboard then
                local list = win._keybinds[input.KeyCode]
                if list then for _, cb in ipairs(list) do pcall(cb) end end
            end
        end)
        win:RegisterTask("keybind-conn", win._keybindConn)
    end

    function CustomGui:_ensureCommandPalette(win, key)
        if win._cmdGui then return end
        local sg = Instance.new("ScreenGui")
        sg.Name = "CommandPalette"
        sg.IgnoreGuiInset = true
        sg.ResetOnSpawn = false
        sg.DisplayOrder = 1_000_001
        pcall(function() if Exec.protect_gui then Exec.protect_gui(sg) end end)
        sg.Parent = choose_ui_parent()
        local box = Instance.new("TextBox")
        box.Size = UDim2.new(0, 420, 0, 36)
        box.Position = UDim2.new(0.5, -210, 0.2, 0)
        local theme = getThemeFor(win.ScreenGui)
        box.BackgroundColor3 = theme.tab
        box.TextColor3 = theme.text
        box.PlaceholderText = "Type command (help)"
        box.Font = Enum.Font.Gotham
        box.TextSize = 18
        box.Parent = sg
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = box
        sg.Enabled = false
        win._cmdGui = sg
        win._cmdBox = box
        -- toggle key
        CustomGui:_ensureKeybindLoop(win)
        win:BindKey(key or Enum.KeyCode.F2, function()
            sg.Enabled = not sg.Enabled
            if sg.Enabled then box:CaptureFocus() end
        end)
        box.FocusLost:Connect(function(enter)
            if enter then
                local text = box.Text
                box.Text = ""
                sg.Enabled = false
                CustomGui:_execCommand(win, text)
            end
        end)
    end

    function CustomGui:_execCommand(win, text)
        text = (text or ""):lower()
        if text == "help" or text == "?" then
            Exec.notify("Commands", "stopall, antiafk on/off, theme carbon/midnight/pastel, rejoin, hop, fps <n>, find <text>, click <number>", 8)
            return
        end
        if text == "stopall" then win:StopAll(); return end
        if text:match("^antiafk ") then
            local arg = text:sub(8):gsub("%s+","")
            win:EnableAntiAFK(arg=="on" or arg=="true" or arg=="1")
            return
        end
        if text:match("^theme ") then
            local name = text:sub(7):gsub("%s+","")
            name = (name:gsub("^%l", string.upper))
            if Themes[name] then
                CustomGui:_applyThemeToWindow(win, name)
            else
                Exec.notify("Theme", "Unknown theme", 3)
            end
            return
        end
        if text == "rejoin" then pcall(function() TeleportService:Teleport(game.PlaceId, LocalPlayer) end); return end
        if text == "hop" or text == "serverhop" then CustomGui:_serverHop(); return end
        local n = tonumber(text:match("^fps%s+(%d+)$"))
        if n then CustomGui:_setFPS(n); return end
        
        -- Find GUI elements command
        local searchTerm = text:match("^find%s+(.+)$")
        if searchTerm then
            win._lastFound = CustomGui:_findGUIElement(searchTerm)
            return
        end
        
        -- Click found element by number
        local clickNum = tonumber(text:match("^click%s+(%d+)$"))
        if clickNum and win._lastFound and win._lastFound[clickNum] then
            local item = win._lastFound[clickNum]
            if item.clickable and item.object then
                pcall(function()
                    if item.object:IsA("TextButton") or item.object:IsA("ImageButton") then
                        -- Simulate click
                        for _, connection in pairs(getconnections(item.object.MouseButton1Click)) do
                            pcall(function() connection:Fire() end)
                        end
                        Exec.notify("GUI Click", "Clicked: " .. item.text, 3)
                        print("Clicked element: " .. item.path)
                    end
                end)
            else
                Exec.notify("GUI Click", "Element not clickable", 3)
            end
            return
        end
        
        Exec.notify("Command", "Unknown command", 2)
    end

    function CustomGui:_setFPS(n)
        local f = (setfpscap or set_fps_cap or setfps)
        if f then pcall(f, n) else Exec.notify("FPS", "Executor doesn’t support fps cap", 3) end
    end

    function CustomGui:_serverHop()
        local ok, err = pcall(function()
            local url = string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100", game.PlaceId)
            local body
            if http_request then
                local res = http_request({Url=url, Method="GET"})
                body = res and (res.Body or res.body)
            else
                body = game:HttpGet(url)
            end
            local data = HttpService:JSONDecode(body)
            for _, s in ipairs(data.data or {}) do
                if s.playing < s.maxPlayers and s.id ~= game.JobId then
                    TeleportService:TeleportToPlaceInstance(game.PlaceId, s.id)
                    return
                end
            end
            TeleportService:Teleport(game.PlaceId)
        end)
        if not ok then pcall(function() TeleportService:Teleport(game.PlaceId) end) end
    end

    function CustomGui:_findGUIElement(searchText)
        searchText = searchText or "Auto Wave"
        local found = {}
        
        -- Search in PlayerGui
        local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
        if playerGui then
            for _, gui in ipairs(playerGui:GetChildren()) do
                CustomGui:_searchInGUI(gui, searchText, found, "PlayerGui." .. gui.Name)
            end
        end
        
        -- Search in CoreGui (if accessible)
        local ok = pcall(function()
            for _, gui in ipairs(CoreGui:GetChildren()) do
                CustomGui:_searchInGUI(gui, searchText, found, "CoreGui." .. gui.Name)
            end
        end)
        
        if #found > 0 then
            print("Found " .. #found .. " elements matching '" .. searchText .. "':")
            for i, item in ipairs(found) do
                print(i .. ". " .. item.path .. " - Text: '" .. item.text .. "' - Type: " .. item.type .. " - Visible: " .. tostring(item.visible))
                if item.clickable then
                    print("   -> This element is clickable!")
                end
            end
            Exec.notify("GUI Finder", "Found " .. #found .. " matches - check console", 5)
        else
            print("No GUI elements found matching '" .. searchText .. "'")
            Exec.notify("GUI Finder", "No matches found for '" .. searchText .. "'", 3)
        end
        
        return found
    end
    
    function CustomGui:_searchInGUI(obj, searchText, found, path)
        if not obj then return end
        
        local text = ""
        local clickable = false
        local objType = obj.ClassName
        
        -- Get text from various GUI elements
        if obj:IsA("TextLabel") or obj:IsA("TextButton") then
            text = obj.Text or ""
            clickable = obj:IsA("TextButton")
        elseif obj:IsA("ImageButton") then
            clickable = true
        end
        
        -- Check if text matches our search
        if text:lower():find(searchText:lower()) then
            table.insert(found, {
                object = obj,
                text = text,
                path = path,
                type = objType,
                visible = obj.Visible,
                clickable = clickable
            })
        end
        
        -- Search children recursively
        for _, child in ipairs(obj:GetChildren()) do
            CustomGui:_searchInGUI(child, searchText, found, path .. "." .. child.Name)
        end
    end
    
    function CustomGui:_createSearchInput(win)
        -- Create a simple input dialog
        local sg = Instance.new("ScreenGui")
        sg.Name = "SearchInput"
        sg.IgnoreGuiInset = true
        sg.ResetOnSpawn = false
        sg.DisplayOrder = 1_000_002
        pcall(function() if Exec.protect_gui then Exec.protect_gui(sg) end end)
        sg.Parent = choose_ui_parent()
        
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(0, 400, 0, 150)
        frame.Position = UDim2.new(0.5, -200, 0.5, -75)
        frame.BackgroundColor3 = Color3.fromRGB(32, 32, 32)
        frame.Parent = sg
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 12)
        corner.Parent = frame
        
        local title = Instance.new("TextLabel")
        title.Size = UDim2.new(1, 0, 0, 40)
        title.Position = UDim2.new(0, 0, 0, 0)
        title.BackgroundTransparency = 1
        title.Text = "Enter Search Term"
        title.TextColor3 = Color3.fromRGB(255, 255, 255)
        title.Font = Enum.Font.GothamBold
        title.TextSize = 18
        title.Parent = frame
        
        local textBox = Instance.new("TextBox")
        textBox.Size = UDim2.new(1, -20, 0, 35)
        textBox.Position = UDim2.new(0, 10, 0, 50)
        textBox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        textBox.TextColor3 = Color3.fromRGB(255, 255, 255)
        textBox.PlaceholderText = "Type search term (e.g., Auto Wave, Shop, Settings)"
        textBox.Font = Enum.Font.Gotham
        textBox.TextSize = 16
        textBox.Parent = frame
        
        local boxCorner = Instance.new("UICorner")
        boxCorner.CornerRadius = UDim.new(0, 6)
        boxCorner.Parent = textBox
        
        local searchBtn = Instance.new("TextButton")
        searchBtn.Size = UDim2.new(0, 80, 0, 30)
        searchBtn.Position = UDim2.new(0, 10, 1, -40)
        searchBtn.BackgroundColor3 = Color3.fromRGB(60, 180, 75)
        searchBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        searchBtn.Text = "Search"
        searchBtn.Font = Enum.Font.GothamBold
        searchBtn.TextSize = 14
        searchBtn.Parent = frame
        
        local searchCorner = Instance.new("UICorner")
        searchCorner.CornerRadius = UDim.new(0, 6)
        searchCorner.Parent = searchBtn
        
        local cancelBtn = Instance.new("TextButton")
        cancelBtn.Size = UDim2.new(0, 80, 0, 30)
        cancelBtn.Position = UDim2.new(1, -90, 1, -40)
        cancelBtn.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
        cancelBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        cancelBtn.Text = "Cancel"
        cancelBtn.Font = Enum.Font.GothamBold
        cancelBtn.TextSize = 14
        cancelBtn.Parent = frame
        
        local cancelCorner = Instance.new("UICorner")
        cancelCorner.CornerRadius = UDim.new(0, 6)
        cancelCorner.Parent = cancelBtn
        
        local function doSearch()
            local searchTerm = textBox.Text:gsub("^%s*(.-)%s*$", "%1") -- trim whitespace
            if searchTerm ~= "" then
                sg:Destroy()
                win._lastFound = CustomGui:_findGUIElement(searchTerm)
                CustomGui:_displayFoundElements(win, win._lastFound)
            end
        end
        
        searchBtn.MouseButton1Click:Connect(doSearch)
        cancelBtn.MouseButton1Click:Connect(function() sg:Destroy() end)
        textBox.FocusLost:Connect(function(enterPressed)
            if enterPressed then doSearch() end
        end)
        
        -- Auto-focus the text box
        task.defer(function() textBox:CaptureFocus() end)
    end
    
    function CustomGui:_displayFoundElements(win, found)
        if not found or #found == 0 then
            print("No GUI elements found")
            Exec.notify("GUI Finder", "No elements found", 3)
            return
        end
        
        print("=== GUI FINDER RESULTS ===")
        print("Found " .. #found .. " elements:")
        print("")
        
        -- Add to in-GUI console
        CustomGui:_addConsoleEntry(win, "GUISearch", string.format("Found %d elements", #found), Color3.fromRGB(100, 255, 150))
        
        for i, item in ipairs(found) do
            print("Result #" .. i .. ":")
            print("  Text: '" .. item.text .. "'")
            print("  Path: " .. item.path)
            print("  Type: " .. item.type)
            print("  Visible: " .. tostring(item.visible))
            print("  Clickable: " .. tostring(item.clickable))
            if item.clickable then
                print("  -> Use 'Click Result #" .. i .. "' button to click this")
            end
            print("")
            
            -- Add detailed entry to console
            local consoleMsg = string.format("#%d: '%s' (%s) - %s", i, item.text, item.type, item.clickable and "Clickable" or "View Only")
            CustomGui:_addConsoleEntry(win, "GUISearch", consoleMsg, Color3.fromRGB(150, 255, 150))
        end
        
        print("=== END RESULTS ===")
        Exec.notify("GUI Finder", "Found " .. #found .. " elements - check console", 5)
    end
    
    function CustomGui:_clickFoundElement(win, index)
        if not win._lastFound or not win._lastFound[index] then
            Exec.notify("GUI Click", "No element #" .. index .. " found", 3)
            print("No element at index " .. index .. ". Search for elements first.")
            return
        end
        
        local item = win._lastFound[index]
        if not item.clickable then
            Exec.notify("GUI Click", "Element #" .. index .. " not clickable", 3)
            print("Element #" .. index .. " is not clickable (Type: " .. item.type .. ")")
            return
        end
        
        local success = false
        pcall(function()
            if item.object and (item.object:IsA("TextButton") or item.object:IsA("ImageButton")) then
                -- Try different methods to click
                if item.object.MouseButton1Click then
                    -- Method 1: Fire the event directly
                    item.object.MouseButton1Click:Fire()
                    success = true
                end
                
                -- Method 2: Try getconnections (if available)
                if not success and getconnections then
                    for _, connection in pairs(getconnections(item.object.MouseButton1Click)) do
                        pcall(function() connection:Fire() end)
                        success = true
                    end
                end
            end
        end)
        
        if success then
            Exec.notify("GUI Click", "Clicked: " .. (item.text ~= "" and item.text or item.path), 3)
            print("Successfully clicked element #" .. index .. ": " .. item.text)
            CustomGui:_addConsoleEntry(win, "Success", string.format("Clicked element #%d: %s", index, item.text), Color3.fromRGB(100, 255, 100))
        else
            Exec.notify("GUI Click", "Failed to click element #" .. index, 3)
            print("Failed to click element #" .. index .. ". The element might not be functional.")
            CustomGui:_addConsoleEntry(win, "Error", string.format("Failed to click element #%d", index), Color3.fromRGB(255, 100, 100))
        end
    end
    
    function CustomGui:_copyElementPath(win, index)
        if not win._lastFound or not win._lastFound[index] then
            Exec.notify("Copy Path", "No element #" .. index .. " found", 3)
            print("No element at index " .. index .. ". Search for elements first.")
            return
        end
        
        local item = win._lastFound[index]
        local pathToCopy = item.path
        
        -- Try to copy to clipboard
        if Exec.setclipboard then
            pcall(function()
                Exec.setclipboard(pathToCopy)
                Exec.notify("Copy Path", "Copied path #" .. index .. " to clipboard", 3)
                print("Copied to clipboard: " .. pathToCopy)
            end)
        else
            -- If no clipboard access, just print it clearly
            Exec.notify("Copy Path", "Path printed to console (no clipboard)", 3)
            print("=== COPY THIS PATH ===")
            print(pathToCopy)
            print("=== END PATH ===")
        end
        
        -- Also print additional info for easy copying
        print("Element #" .. index .. " details:")
        print("  Path: " .. pathToCopy)
        print("  Text: '" .. item.text .. "'")
        print("  Type: " .. item.type)
        
        -- Generate a code snippet for accessing this element
        local codeSnippet = "game." .. pathToCopy:gsub("^[^%.]+%.", "")
        print("  Code snippet: " .. codeSnippet)
        
        if Exec.setclipboard then
            print("  (Path copied to clipboard)")
        else
            print("  (Select and copy the path above)")
        end
    end
    
    function CustomGui:_copyAllPaths(win)
        if not win._lastFound or #win._lastFound == 0 then
            Exec.notify("Copy Paths", "No search results to copy", 3)
            print("No search results found. Search for elements first.")
            return
        end
        
        local allPaths = {}
        local allInfo = {}
        
        for i, item in ipairs(win._lastFound) do
            table.insert(allPaths, item.path)
            table.insert(allInfo, string.format("-- Element #%d: '%s' (%s)\n%s", 
                i, item.text, item.type, item.path))
        end
        
        local pathsText = table.concat(allPaths, "\n")
        local infoText = table.concat(allInfo, "\n\n")
        
        -- Try to copy to clipboard
        if Exec.setclipboard then
            pcall(function()
                Exec.setclipboard(pathsText)
                Exec.notify("Copy Paths", "Copied " .. #allPaths .. " paths to clipboard", 4)
                print("Copied " .. #allPaths .. " paths to clipboard")
            end)
        else
            Exec.notify("Copy Paths", "Paths printed to console (no clipboard)", 3)
        end
        
        -- Print detailed info to console
        print("=== ALL FOUND ELEMENT PATHS ===")
        print(infoText)
        print("\n=== PATHS ONLY (for copying) ===")
        print(pathsText)
        print("=== END PATHS ===")
        
        if Exec.setclipboard then
            print("(All paths copied to clipboard)")
        else
            print("(Select and copy the paths above)")
        end
    end
    
    function CustomGui:_buildRemoteDetectorTab(win)
        local tab = win:MakeTab({ Name = "Remote Detector" })
        
        -- Store for remote detection
        win._remoteStore = win._remoteStore or win:CreateStore("remote_detector")
        win._remoteConnections = win._remoteConnections or {}
        win._remoteStats = win._remoteStats or {}
        win._ignoredRemotes = win._ignoredRemotes or {}
        win._blockedRemotes = win._blockedRemotes or {}
        win._remoteDetectorActive = win._remoteDetectorActive or false
        
        local rStore = win._remoteStore
        local settings = rStore:Get("settings", {
            logToConsole = true,
            showArgs = false,
            maxDisplayed = 50,
            autoScroll = true
        })
        local function rsave() rStore:Set("settings", settings) end
        
        CustomGui:AddLabel(tab, "Remote Event & Function Monitor")
        
        -- Main controls
        CustomGui:AddToggle(tab, { Name = "Enable Remote Detection", Default = false, Callback = function(on)
            CustomGui:_toggleRemoteDetection(win, on)
        end })
        
        CustomGui:AddToggle(tab, { Name = "Log to Console", Default = settings.logToConsole, Callback = function(on)
            settings.logToConsole = on; rsave()
        end })
        
        CustomGui:AddToggle(tab, { Name = "Show Arguments", Default = settings.showArgs, Callback = function(on)
            settings.showArgs = on; rsave()
        end })
        
        -- Display controls
        CustomGui:AddLabel(tab, "Display Options:")
        
        CustomGui:AddSlider(tab, { Name = "Max Displayed Remotes", Min = 10, Max = 200, Default = settings.maxDisplayed or 50, Callback = function(v)
            settings.maxDisplayed = math.floor(v); rsave()
        end })
        
        CustomGui:AddButton(tab, { Name = "Clear Remote List", Callback = function()
            CustomGui:_clearRemoteList(win)
        end })
        
        CustomGui:AddButton(tab, { Name = "Copy Remote List", Callback = function()
            CustomGui:_copyRemoteList(win)
        end })
        
        -- Stats and management
        CustomGui:AddLabel(tab, "Remote Management:")
        
        CustomGui:AddButton(tab, { Name = "Show Remote Stats", Callback = function()
            CustomGui:_showRemoteStats(win)
        end })
        
        CustomGui:AddButton(tab, { Name = "Block Last Remote", Callback = function()
            CustomGui:_blockLastRemote(win)
        end })
        
        CustomGui:AddButton(tab, { Name = "Ignore Last Remote", Callback = function()
            CustomGui:_ignoreLastRemote(win)
        end })
        
        CustomGui:AddButton(tab, { Name = "Show Ignored/Blocked", Callback = function()
            CustomGui:_showIgnoredBlocked(win)
        end })
        
        CustomGui:AddButton(tab, { Name = "Clear All Blocks/Ignores", Callback = function()
            win._ignoredRemotes = {}
            win._blockedRemotes = {}
            print("Cleared all ignored and blocked remotes")
            Exec.notify("Remote Detector", "Cleared all blocks and ignores", 3)
        end })
        
        -- Remote Browser section
        CustomGui:AddLabel(tab, "Remote Browser & Analysis:")
        
        CustomGui:AddButton(tab, { Name = "Browse All Remotes", Callback = function()
            CustomGui:_browseAllRemotes(win)
        end })
        
        CustomGui:AddButton(tab, { Name = "Show Remote Details", Callback = function()
            CustomGui:_showRemoteDetails(win)
        end })
        
        CustomGui:AddButton(tab, { Name = "Generate Remote Code", Callback = function()
            CustomGui:_generateRemoteCode(win)
        end })
        
        CustomGui:AddButton(tab, { Name = "Export Remote Data", Callback = function()
            CustomGui:_exportRemoteData(win)
        end })
        
        return tab
    end
    
    function CustomGui:_toggleRemoteDetection(win, enabled)
        win._remoteDetectorActive = enabled
        
        if enabled then
            -- Start detecting remotes
            CustomGui:_startRemoteDetection(win)
            Exec.notify("Remote Detector", "Started monitoring remotes", 3)
            print("Remote detection started - monitoring all RemoteEvents and RemoteFunctions")
            CustomGui:_addConsoleEntry(win, "Info", "Remote monitoring started", Color3.fromRGB(100, 200, 255))
        else
            -- Stop detecting remotes
            CustomGui:_stopRemoteDetection(win)
            Exec.notify("Remote Detector", "Stopped monitoring remotes", 3)
            print("Remote detection stopped")
            CustomGui:_addConsoleEntry(win, "Info", "Remote monitoring stopped", Color3.fromRGB(200, 200, 100))
        end
    end
    
    function CustomGui:_startRemoteDetection(win)
        CustomGui:_stopRemoteDetection(win) -- Clean up first
        
        win._remoteLog = win._remoteLog or {}
        win._lastRemote = nil
        
        -- Function to hook a remote
        local function hookRemote(remote, remoteType)
            if win._ignoredRemotes[remote] then return end
            
            -- Hook FireServer for RemoteEvents
            if remoteType == "RemoteEvent" and hookfunction then
                pcall(function()
                    local old = remote.FireServer
                    remote.FireServer = hookfunction(old, function(...)
                        CustomGui:_logRemote(win, remote, remoteType, {...})
                        return old(...)
                    end)
                end)
            elseif remoteType == "RemoteFunction" and hookfunction then
                pcall(function()
                    local old = remote.InvokeServer
                    remote.InvokeServer = hookfunction(old, function(...)
                        CustomGui:_logRemote(win, remote, remoteType, {...})
                        return old(...)
                    end)
                end)
            end
            
            table.insert(win._remoteConnections, {remote = remote, type = remoteType})
        end
        
        -- Hook existing remotes
        local function scanForRemotes(parent)
            for _, obj in ipairs(parent:GetDescendants()) do
                if obj:IsA("RemoteEvent") or obj:IsA("RemoteFunction") then
                    hookRemote(obj, obj.ClassName)
                end
            end
        end
        
        -- Scan ReplicatedStorage and other common locations
        scanForRemotes(game:GetService("ReplicatedStorage"))
        pcall(function() scanForRemotes(game:GetService("ReplicatedFirst")) end)
        pcall(function() scanForRemotes(game:GetService("Lighting")) end)
        
        -- Hook new remotes as they're added
        local function onChildAdded(child)
            if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
                task.wait(0.1) -- Small delay to ensure remote is fully loaded
                hookRemote(child, child.ClassName)
            end
        end
        
        local repStorage = game:GetService("ReplicatedStorage")
        table.insert(win._remoteConnections, repStorage.DescendantAdded:Connect(onChildAdded))
    end
    
    function CustomGui:_stopRemoteDetection(win)
        -- Disconnect all connections
        for _, conn in ipairs(win._remoteConnections or {}) do
            if typeof(conn) == "RBXScriptConnection" then
                pcall(function() conn:Disconnect() end)
            end
        end
        win._remoteConnections = {}
    end
    
    function CustomGui:_logRemote(win, remote, remoteType, args)
        if not win._remoteDetectorActive then return end
        if win._ignoredRemotes[remote] then return end
        
        -- Check if remote is blocked
        if win._blockedRemotes[remote] then
            print("🚫 BLOCKED: " .. remote:GetFullName())
            return -- Don't execute the remote
        end
        
        win._lastRemote = remote
        
        -- Update stats
        local name = remote:GetFullName()
        win._remoteStats[name] = (win._remoteStats[name] or 0) + 1
        
        -- Create log entry
        local logEntry = {
            name = name,
            type = remoteType,
            time = os.date("%H:%M:%S"),
            args = args,
            count = win._remoteStats[name]
        }
        
        -- Add to log
        win._remoteLog = win._remoteLog or {}
        table.insert(win._remoteLog, logEntry)
        
        -- Keep only recent entries
        local maxEntries = (win._remoteStore and win._remoteStore:Get("settings", {}).maxDisplayed) or 50
        while #win._remoteLog > maxEntries do
            table.remove(win._remoteLog, 1)
        end
        
        -- Log to console if enabled
        local settings = (win._remoteStore and win._remoteStore:Get("settings", {})) or {}
        if settings.logToConsole ~= false then
            local logText = string.format("[%s] %s (%s) - Count: %d", 
                logEntry.time, logEntry.name, logEntry.type, logEntry.count)
            
            if settings.showArgs and args and #args > 0 then
                local argStrings = {}
                for i, arg in ipairs(args) do
                    if i > 5 then -- Limit arg display
                        table.insert(argStrings, "...")
                        break
                    end
                    table.insert(argStrings, tostring(arg))
                end
                logText = logText .. " | Args: " .. table.concat(argStrings, ", ")
            end
            
            print(logText)
        end
        
        -- Add to in-GUI console
        local consoleMessage = string.format("%s - Count: %d", logEntry.name, logEntry.count)
        if win._consoleShowArgs and args and #args > 0 then
            local argStrings = {}
            for i, arg in ipairs(args) do
                if i > 3 then
                    table.insert(argStrings, "...")
                    break
                end
                table.insert(argStrings, tostring(arg))
            end
            consoleMessage = consoleMessage .. " | Args: " .. table.concat(argStrings, ", ")
        end
        
        local color = remoteType == "RemoteEvent" and Color3.fromRGB(100, 200, 255) or Color3.fromRGB(255, 150, 100)
        CustomGui:_addConsoleEntry(win, remoteType, consoleMessage, color)
    end
    
    function CustomGui:_clearRemoteList(win)
        win._remoteLog = {}
        win._remoteStats = {}
        print("Remote list cleared")
        Exec.notify("Remote Detector", "Remote list cleared", 2)
    end
    
    function CustomGui:_copyRemoteList(win)
        if not win._remoteLog or #win._remoteLog == 0 then
            Exec.notify("Remote Detector", "No remotes to copy", 3)
            return
        end
        
        local lines = {"=== REMOTE DETECTOR LOG ===", ""}
        for _, entry in ipairs(win._remoteLog) do
            local line = string.format("[%s] %s (%s) - Count: %d", 
                entry.time, entry.name, entry.type, entry.count)
            table.insert(lines, line)
        end
        table.insert(lines, "")
        table.insert(lines, "=== END LOG ===")
        
        local logText = table.concat(lines, "\n")
        
        if Exec.setclipboard then
            pcall(function()
                Exec.setclipboard(logText)
                Exec.notify("Remote Detector", "Log copied to clipboard", 3)
            end)
        else
            Exec.notify("Remote Detector", "Log printed to console", 3)
        end
        
        print(logText)
    end
    
    function CustomGui:_showRemoteStats(win)
        if not win._remoteStats or next(win._remoteStats) == nil then
            print("No remote statistics available")
            Exec.notify("Remote Detector", "No stats available", 3)
            return
        end
        
        print("=== REMOTE STATISTICS ===")
        
        -- Sort by call count
        local sorted = {}
        for name, count in pairs(win._remoteStats) do
            table.insert(sorted, {name = name, count = count})
        end
        table.sort(sorted, function(a, b) return a.count > b.count end)
        
        print("Top remotes by call count:")
        for i, entry in ipairs(sorted) do
            if i > 20 then break end -- Show top 20
            print(string.format("%d. %s - %d calls", i, entry.name, entry.count))
        end
        
        print("\nTotal unique remotes tracked: " .. #sorted)
        print("=== END STATISTICS ===")
        
        Exec.notify("Remote Detector", "Stats shown in console", 3)
    end
    
    function CustomGui:_blockLastRemote(win)
        if not win._lastRemote then
            Exec.notify("Remote Detector", "No recent remote to block", 3)
            return
        end
        
        local remote = win._lastRemote
        win._blockedRemotes[remote] = true
        
        local name = remote:GetFullName()
        print("🚫 BLOCKED REMOTE: " .. name)
        Exec.notify("Remote Detector", "Blocked: " .. remote.Name, 3)
    end
    
    function CustomGui:_ignoreLastRemote(win)
        if not win._lastRemote then
            Exec.notify("Remote Detector", "No recent remote to ignore", 3)
            return
        end
        
        local remote = win._lastRemote
        win._ignoredRemotes[remote] = true
        
        local name = remote:GetFullName()
        print("🔇 IGNORED REMOTE: " .. name)
        Exec.notify("Remote Detector", "Ignored: " .. remote.Name, 3)
    end
    
    function CustomGui:_showIgnoredBlocked(win)
        print("=== IGNORED & BLOCKED REMOTES ===")
        
        print("\n🔇 IGNORED REMOTES:")
        local ignoredCount = 0
        for remote, _ in pairs(win._ignoredRemotes or {}) do
            if remote and remote.Parent then
                print("  " .. remote:GetFullName())
                ignoredCount = ignoredCount + 1
            end
        end
        if ignoredCount == 0 then print("  None") end
        
        print("\n🚫 BLOCKED REMOTES:")
        local blockedCount = 0
        for remote, _ in pairs(win._blockedRemotes or {}) do
            if remote and remote.Parent then
                print("  " .. remote:GetFullName())
                blockedCount = blockedCount + 1
            end
        end
        if blockedCount == 0 then print("  None") end
        
        print("\n=== END LIST ===")
        Exec.notify("Remote Detector", string.format("%d ignored, %d blocked", ignoredCount, blockedCount), 3)
    end
    
    function CustomGui:_browseAllRemotes(win)
        print("=== REMOTE BROWSER ===")
        print("Scanning game for all RemoteEvents and RemoteFunctions...")
        
        local foundRemotes = {}
        
        -- Scan function
        local function scanLocation(parent, locationName)
            local remotes = {}
            pcall(function()
                for _, obj in ipairs(parent:GetDescendants()) do
                    if obj:IsA("RemoteEvent") or obj:IsA("RemoteFunction") then
                        table.insert(remotes, {
                            name = obj.Name,
                            path = obj:GetFullName(),
                            type = obj.ClassName,
                            parent = obj.Parent and obj.Parent.Name or "Unknown",
                            location = locationName
                        })
                    end
                end
            end)
            return remotes
        end
        
        -- Scan different locations
        local locations = {
            {game:GetService("ReplicatedStorage"), "ReplicatedStorage"},
            {game:GetService("ReplicatedFirst"), "ReplicatedFirst"},
            {game:GetService("Lighting"), "Lighting"},
            {game:GetService("Workspace"), "Workspace"},
        }
        
        -- Try ServerStorage if accessible
        pcall(function()
            table.insert(locations, {game:GetService("ServerStorage"), "ServerStorage"})
        end)
        
        for _, loc in ipairs(locations) do
            local remotes = scanLocation(loc[1], loc[2])
            for _, remote in ipairs(remotes) do
                table.insert(foundRemotes, remote)
            end
        end
        
        -- Store results for later use
        win._allRemotes = foundRemotes
        
        print(string.format("\nFound %d remotes across %d locations:", #foundRemotes, #locations))
        print("\n📋 REMOTE INVENTORY:")
        
        -- Group by location
        local byLocation = {}
        for _, remote in ipairs(foundRemotes) do
            byLocation[remote.location] = byLocation[remote.location] or {}
            table.insert(byLocation[remote.location], remote)
        end
        
        for location, remotes in pairs(byLocation) do
            print(string.format("\n📁 %s (%d remotes):", location, #remotes))
            for i, remote in ipairs(remotes) do
                local icon = remote.type == "RemoteEvent" and "📡" or "🔧"
                print(string.format("  %s %d. %s (%s)", icon, i, remote.name, remote.type))
                print(string.format("     Path: %s", remote.path))
            end
        end
        
        print("\n=== END BROWSER ===")
        print("Use 'Show Remote Details' to analyze specific remotes")
        
        Exec.notify("Remote Browser", string.format("Found %d remotes", #foundRemotes), 4)
        CustomGui:_addConsoleEntry(win, "Info", string.format("Scanned game: Found %d remotes across %d locations", #foundRemotes, #locations), Color3.fromRGB(150, 200, 255))
    end
    
    function CustomGui:_showRemoteDetails(win)
        if not win._allRemotes or #win._allRemotes == 0 then
            print("No remotes found. Run 'Browse All Remotes' first.")
            Exec.notify("Remote Details", "Browse remotes first", 3)
            return
        end
        
        print("=== REMOTE DETAILS & ANALYSIS ===")
        
        -- Show recent activity if available
        if win._remoteLog and #win._remoteLog > 0 then
            print("\n🔥 RECENT ACTIVITY (Last 10 calls):")
            local recent = {}
            for i = math.max(1, #win._remoteLog - 9), #win._remoteLog do
                table.insert(recent, win._remoteLog[i])
            end
            
            for i, entry in ipairs(recent) do
                local argText = ""
                if entry.args and #entry.args > 0 then
                    local args = {}
                    for j, arg in ipairs(entry.args) do
                        if j > 3 then table.insert(args, "..."); break end
                        local argStr = tostring(arg)
                        if #argStr > 20 then argStr = argStr:sub(1, 20) .. "..." end
                        table.insert(args, argStr)
                    end
                    argText = " | Args: " .. table.concat(args, ", ")
                end
                print(string.format("  [%s] %s (%s)%s", entry.time, entry.name, entry.type, argText))
            end
        end
        
        -- Show statistics if available
        if win._remoteStats and next(win._remoteStats) then
            print("\n📊 CALL STATISTICS:")
            local sorted = {}
            for name, count in pairs(win._remoteStats) do
                table.insert(sorted, {name = name, count = count})
            end
            table.sort(sorted, function(a, b) return a.count > b.count end)
            
            for i = 1, math.min(10, #sorted) do
                local entry = sorted[i]
                print(string.format("  %d. %s - %d calls", i, entry.name:match("[^%.]+$") or entry.name, entry.count))
            end
        end
        
        -- Remote analysis
        print("\n🔍 REMOTE ANALYSIS:")
        local eventCount = 0
        local functionCount = 0
        local byParent = {}
        
        for _, remote in ipairs(win._allRemotes) do
            if remote.type == "RemoteEvent" then
                eventCount = eventCount + 1
            else
                functionCount = functionCount + 1
            end
            
            byParent[remote.parent] = (byParent[remote.parent] or 0) + 1
        end
        
        print(string.format("  📡 RemoteEvents: %d", eventCount))
        print(string.format("  🔧 RemoteFunctions: %d", functionCount))
        print(string.format("  📁 Total Parents: %d", table.maxn and table.maxn(byParent) or 0))
        
        print("\n🏗️ PARENT DISTRIBUTION:")
        local parentList = {}
        for parent, count in pairs(byParent) do
            table.insert(parentList, {parent = parent, count = count})
        end
        table.sort(parentList, function(a, b) return a.count > b.count end)
        
        for i = 1, math.min(5, #parentList) do
            print(string.format("  %s: %d remotes", parentList[i].parent, parentList[i].count))
        end
        
        print("\n=== END DETAILS ===")
        Exec.notify("Remote Details", "Analysis complete", 3)
    end
    
    function CustomGui:_generateRemoteCode(win)
        if not win._allRemotes or #win._allRemotes == 0 then
            print("No remotes found. Run 'Browse All Remotes' first.")
            Exec.notify("Remote Code", "Browse remotes first", 3)
            return
        end
        
        print("=== REMOTE CODE GENERATOR ===")
        
        local codeLines = {
            "-- Generated Remote Code",
            "-- Copy and paste the sections you need",
            "",
            "-- Services",
            "local ReplicatedStorage = game:GetService('ReplicatedStorage')",
            "local Players = game:GetService('Players')",
            "local LocalPlayer = Players.LocalPlayer",
            "",
            "-- Remote References"
        }
        
        -- Generate reference variables
        for _, remote in ipairs(win._allRemotes) do
            local varName = remote.name:gsub("[^%w]", ""):gsub("^%l", string.upper) .. remote.type:gsub("Remote", "")
            local line = string.format("local %s = %s", varName, remote.path)
            table.insert(codeLines, line)
        end
        
        table.insert(codeLines, "")
        table.insert(codeLines, "-- Usage Examples")
        
        -- Generate usage examples
        for _, remote in ipairs(win._allRemotes) do
            local varName = remote.name:gsub("[^%w]", ""):gsub("^%l", string.upper) .. remote.type:gsub("Remote", "")
            
            if remote.type == "RemoteEvent" then
                table.insert(codeLines, string.format("-- %s:FireServer(arg1, arg2, ...)", varName))
            else
                table.insert(codeLines, string.format("-- local result = %s:InvokeServer(arg1, arg2, ...)", varName))
            end
        end
        
        -- Add common patterns based on call logs
        if win._remoteLog and #win._remoteLog > 0 then
            table.insert(codeLines, "")
            table.insert(codeLines, "-- Common Call Patterns (from logs)")
            
            local patterns = {}
            for _, entry in ipairs(win._remoteLog) do
                local pattern = entry.name:match("[^%.]+$") or entry.name
                if not patterns[pattern] then
                    patterns[pattern] = {
                        name = pattern,
                        path = entry.name,
                        type = entry.type,
                        args = entry.args
                    }
                end
            end
            
            for _, pattern in pairs(patterns) do
                if pattern.args and #pattern.args > 0 then
                    local argExample = {}
                    for i, arg in ipairs(pattern.args) do
                        if i > 3 then break end
                        table.insert(argExample, string.format("'%s'", tostring(arg)))
                    end
                    local method = pattern.type == "RemoteEvent" and "FireServer" or "InvokeServer"
                    table.insert(codeLines, string.format("-- %s:%s(%s)", pattern.path, method, table.concat(argExample, ", ")))
                end
            end
        end
        
        local fullCode = table.concat(codeLines, "\n")
        
        -- Copy to clipboard if available
        if Exec.setclipboard then
            pcall(function()
                Exec.setclipboard(fullCode)
                Exec.notify("Remote Code", "Code copied to clipboard", 4)
                print("✅ Remote code copied to clipboard!")
            end)
        else
            Exec.notify("Remote Code", "Code printed to console", 3)
        end
        
        print("=== GENERATED CODE ===")
        print(fullCode)
        print("=== END CODE ===")
        
        if not Exec.setclipboard then
            print("Select and copy the code above to use it.")
        end
    end
    
    function CustomGui:_exportRemoteData(win)
        local exportData = {
            timestamp = os.date("%Y-%m-%d %H:%M:%S"),
            gameInfo = {
                placeId = game.PlaceId,
                jobId = game.JobId,
                placeName = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name or "Unknown"
            },
            remotes = win._allRemotes or {},
            callLogs = win._remoteLog or {},
            statistics = win._remoteStats or {},
            ignoredRemotes = {},
            blockedRemotes = {}
        }
        
        -- Convert ignored/blocked to exportable format
        for remote, _ in pairs(win._ignoredRemotes or {}) do
            if remote and remote.Parent then
                table.insert(exportData.ignoredRemotes, remote:GetFullName())
            end
        end
        
        for remote, _ in pairs(win._blockedRemotes or {}) do
            if remote and remote.Parent then
                table.insert(exportData.blockedRemotes, remote:GetFullName())
            end
        end
        
        -- Generate detailed report
        local report = {
            "=== REMOTE SPY EXPORT REPORT ===",
            "Generated: " .. exportData.timestamp,
            "",
            "📍 GAME INFO:",
            "  Place ID: " .. exportData.gameInfo.placeId,
            "  Job ID: " .. exportData.gameInfo.jobId,
            "  Place Name: " .. exportData.gameInfo.placeName,
            "",
            "📋 REMOTE INVENTORY:",
            "  Total Remotes: " .. #exportData.remotes,
            "  RemoteEvents: " .. table.concat({}, ""),  -- Will calculate below
            "  RemoteFunctions: " .. table.concat({}, ""), -- Will calculate below
            "",
            "📊 ACTIVITY STATISTICS:",
            "  Total Calls Logged: " .. #exportData.callLogs,
            "  Unique Remotes Called: " .. table.concat({}, ""), -- Will calculate below
            "",
            "🔇 FILTERING:",
            "  Ignored Remotes: " .. #exportData.ignoredRemotes,
            "  Blocked Remotes: " .. #exportData.blockedRemotes,
            "",
            "=== DETAILED DATA ==="
        }
        
        -- Calculate counts
        local eventCount, functionCount = 0, 0
        for _, remote in ipairs(exportData.remotes) do
            if remote.type == "RemoteEvent" then eventCount = eventCount + 1
            else functionCount = functionCount + 1 end
        end
        
        report[9] = "  RemoteEvents: " .. eventCount
        report[10] = "  RemoteFunctions: " .. functionCount
        report[14] = "  Unique Remotes Called: " .. table.concat({}, tostring(next(exportData.statistics) and 0 or 0))
        
        -- Add remote list
        table.insert(report, "\n📡 ALL REMOTES:")
        for i, remote in ipairs(exportData.remotes) do
            table.insert(report, string.format("%d. %s (%s) - %s", i, remote.name, remote.type, remote.path))
        end
        
        -- Add call statistics
        if next(exportData.statistics) then
            table.insert(report, "\n📈 CALL STATISTICS:")
            local sortedStats = {}
            for name, count in pairs(exportData.statistics) do
                table.insert(sortedStats, {name = name, count = count})
            end
            table.sort(sortedStats, function(a, b) return a.count > b.count end)
            
            for i, stat in ipairs(sortedStats) do
                table.insert(report, string.format("%d. %s - %d calls", i, stat.name, stat.count))
            end
        end
        
        -- Add recent logs
        if #exportData.callLogs > 0 then
            table.insert(report, "\n📝 RECENT CALL LOG:")
            for i, log in ipairs(exportData.callLogs) do
                local argText = ""
                if log.args and #log.args > 0 then
                    argText = " | Args: " .. table.concat(log.args, ", ", 1, math.min(3, #log.args))
                end
                table.insert(report, string.format("[%s] %s (%s)%s", log.time, log.name, log.type, argText))
            end
        end
        
        table.insert(report, "\n=== END EXPORT ===")
        
        local fullReport = table.concat(report, "\n")
        
        -- Copy to clipboard
        if Exec.setclipboard then
            pcall(function()
                Exec.setclipboard(fullReport)
                Exec.notify("Remote Export", "Report copied to clipboard", 4)
                print("✅ Remote data exported to clipboard!")
            end)
        else
            Exec.notify("Remote Export", "Report printed to console", 3)
        end
        
        print(fullReport)
        
        -- Also try to save to file if possible
        if Exec.writefile then
            pcall(function()
                local filename = string.format("RemoteSpy_%s_%d.txt", os.date("%Y%m%d_%H%M%S"), game.PlaceId)
                Exec.writefile(filename, fullReport)
            print("💾 Also saved to file: " .. filename)
        end)
    end
    
    function CustomGui:_buildConsoleTab(win)
        local tab = win:MakeTab({ Name = "Console" })
        
        -- Create console GUI
        win._consoleFrame = win._consoleFrame or CustomGui:_createConsole(win)
        
        CustomGui:AddLabel(tab, "In-GUI Console - Live Remote & GUI Log")
        
        -- Console controls
        CustomGui:AddToggle(tab, { Name = "Enable Console Logging", Default = true, Callback = function(on)
            win._consoleEnabled = on
            if win._consoleFrame then
                win._consoleFrame.Visible = on
            end
        end })
        
        CustomGui:AddToggle(tab, { Name = "Auto Scroll", Default = true, Callback = function(on)
            win._consoleAutoScroll = on
        end })
        
        CustomGui:AddToggle(tab, { Name = "Show Timestamps", Default = true, Callback = function(on)
            win._consoleShowTime = on
        end })
        
        CustomGui:AddSlider(tab, { Name = "Max Console Lines", Min = 50, Max = 1000, Default = 200, Callback = function(v)
            win._consoleMaxLines = math.floor(v)
        end })
        
        -- Console actions
        CustomGui:AddButton(tab, { Name = "Clear Console", Callback = function()
            CustomGui:_clearConsole(win)
        end })
        
        CustomGui:AddButton(tab, { Name = "Copy Console Log", Callback = function()
            CustomGui:_copyConsoleLog(win)
        end })
        
        CustomGui:AddButton(tab, { Name = "Toggle Console Window", Callback = function()
            if win._consoleFrame then
                win._consoleFrame.Visible = not win._consoleFrame.Visible
            end
        end })
        
        -- Filter options
        CustomGui:AddLabel(tab, "Console Filters:")
        
        CustomGui:AddToggle(tab, { Name = "Show Remote Events", Default = true, Callback = function(on)
            win._consoleShowRemoteEvents = on
        end })
        
        CustomGui:AddToggle(tab, { Name = "Show Remote Functions", Default = true, Callback = function(on)
            win._consoleShowRemoteFunctions = on
        end })
        
        CustomGui:AddToggle(tab, { Name = "Show GUI Searches", Default = true, Callback = function(on)
            win._consoleShowGUISearches = on
        end })
        
        CustomGui:AddToggle(tab, { Name = "Show Arguments", Default = false, Callback = function(on)
            win._consoleShowArgs = on
        end })
        
        -- Initialize console settings
        win._consoleEnabled = win._consoleEnabled or true
        win._consoleAutoScroll = win._consoleAutoScroll or true
        win._consoleShowTime = win._consoleShowTime or true
        win._consoleMaxLines = win._consoleMaxLines or 200
        win._consoleShowRemoteEvents = win._consoleShowRemoteEvents or true
        win._consoleShowRemoteFunctions = win._consoleShowRemoteFunctions or true
        win._consoleShowGUISearches = win._consoleShowGUISearches or true
        win._consoleShowArgs = win._consoleShowArgs or false
        win._consoleLog = win._consoleLog or {}
        
        return tab
    end
    
    function CustomGui:_createConsole(win)
        local sg = Instance.new("ScreenGui")
        sg.Name = "CustomGuiConsole"
        sg.IgnoreGuiInset = true
        sg.ResetOnSpawn = false
        sg.DisplayOrder = 999999
        pcall(function() if Exec.protect_gui then Exec.protect_gui(sg) end end)
        sg.Parent = choose_ui_parent()
        
        -- Main console frame
        local frame = Instance.new("Frame")
        frame.Name = "ConsoleFrame"
        frame.Size = UDim2.new(0, 600, 0, 400)
        frame.Position = UDim2.new(1, -620, 0, 20) -- Top right corner
        frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        frame.BorderSizePixel = 0
        frame.Parent = sg
        frame.Active = true
        
        local frameCorner = Instance.new("UICorner")
        frameCorner.CornerRadius = UDim.new(0, 8)
        frameCorner.Parent = frame
        
        -- Title bar
        local titleBar = Instance.new("Frame")
        titleBar.Name = "TitleBar"
        titleBar.Size = UDim2.new(1, 0, 0, 30)
        titleBar.Position = UDim2.new(0, 0, 0, 0)
        titleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        titleBar.Parent = frame
        
        local titleCorner = Instance.new("UICorner")
        titleCorner.CornerRadius = UDim.new(0, 8)
        titleCorner.Parent = titleBar
        
        local title = Instance.new("TextLabel")
        title.Size = UDim2.new(1, -60, 1, 0)
        title.Position = UDim2.new(0, 5, 0, 0)
        title.BackgroundTransparency = 1
        title.Text = "🕵️ Remote Console"
        title.TextColor3 = Color3.fromRGB(255, 255, 255)
        title.Font = Enum.Font.GothamBold
        title.TextSize = 14
        title.TextXAlignment = Enum.TextXAlignment.Left
        title.Parent = titleBar
        
        -- Close button
        local closeBtn = Instance.new("TextButton")
        closeBtn.Size = UDim2.new(0, 25, 0, 25)
        closeBtn.Position = UDim2.new(1, -30, 0, 2.5)
        closeBtn.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
        closeBtn.Text = "×"
        closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        closeBtn.Font = Enum.Font.GothamBold
        closeBtn.TextSize = 16
        closeBtn.Parent = titleBar
        
        local closeBtnCorner = Instance.new("UICorner")
        closeBtnCorner.CornerRadius = UDim.new(0, 4)
        closeBtnCorner.Parent = closeBtn
        
        closeBtn.MouseButton1Click:Connect(function()
            frame.Visible = false
        end)
        
        -- Console content area
        local contentFrame = Instance.new("ScrollingFrame")
        contentFrame.Name = "Content"
        contentFrame.Size = UDim2.new(1, -10, 1, -40)
        contentFrame.Position = UDim2.new(0, 5, 0, 35)
        contentFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
        contentFrame.BorderSizePixel = 0
        contentFrame.ScrollBarThickness = 8
        contentFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        contentFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
        contentFrame.ScrollingDirection = Enum.ScrollingDirection.Y
        contentFrame.Parent = frame
        
        local contentCorner = Instance.new("UICorner")
        contentCorner.CornerRadius = UDim.new(0, 4)
        contentCorner.Parent = contentFrame
        
        -- Layout for console entries
        local layout = Instance.new("UIListLayout")
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Padding = UDim.new(0, 2)
        layout.Parent = contentFrame
        
        -- Make draggable
        local dragging = false
        local dragStart = nil
        local startPos = nil
        
        titleBar.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                dragStart = input.Position
                startPos = frame.Position
            end
        end)
        
        titleBar.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local delta = input.Position - dragStart
                frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            end
        end)
        
        titleBar.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
            end
        end)
        
        win._consoleFrame = frame
        win._consoleContent = contentFrame
        win._consoleLayout = layout
        
        return frame
    end
    
    function CustomGui:_addConsoleEntry(win, entryType, message, color)
        if not win._consoleEnabled or not win._consoleContent then return end
        
        -- Filter based on settings
        if entryType == "RemoteEvent" and not win._consoleShowRemoteEvents then return end
        if entryType == "RemoteFunction" and not win._consoleShowRemoteFunctions then return end
        if entryType == "GUISearch" and not win._consoleShowGUISearches then return end
        
        win._consoleLog = win._consoleLog or {}
        
        -- Create console entry
        local entry = Instance.new("Frame")
        entry.Size = UDim2.new(1, -10, 0, 0)
        entry.BackgroundTransparency = 1
        entry.AutomaticSize = Enum.AutomaticSize.Y
        entry.LayoutOrder = #win._consoleLog + 1
        entry.Parent = win._consoleContent
        
        local entryLayout = Instance.new("UIListLayout")
        entryLayout.SortOrder = Enum.SortOrder.LayoutOrder
        entryLayout.Padding = UDim.new(0, 2)
        entryLayout.Parent = entry
        
        -- Timestamp
        if win._consoleShowTime then
            local timeLabel = Instance.new("TextLabel")
            timeLabel.Size = UDim2.new(1, 0, 0, 16)
            timeLabel.BackgroundTransparency = 1
            timeLabel.Text = "[" .. os.date("%H:%M:%S") .. "]"
            timeLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
            timeLabel.Font = Enum.Font.RobotoMono
            timeLabel.TextSize = 12
            timeLabel.TextXAlignment = Enum.TextXAlignment.Left
            timeLabel.LayoutOrder = 1
            timeLabel.Parent = entry
        end
        
        -- Entry type icon
        local typeIcon = "📡"
        if entryType == "RemoteFunction" then typeIcon = "🔧"
        elseif entryType == "GUISearch" then typeIcon = "�"
        elseif entryType == "Info" then typeIcon = "ℹ️"
        elseif entryType == "Warning" then typeIcon = "⚠️"
        elseif entryType == "Error" then typeIcon = "❌"
        elseif entryType == "Success" then typeIcon = "✅"
        end
        
        -- Main message
        local messageLabel = Instance.new("TextLabel")
        messageLabel.Size = UDim2.new(1, 0, 0, 0)
        messageLabel.BackgroundTransparency = 1
        messageLabel.Text = typeIcon .. " " .. message
        messageLabel.TextColor3 = color or Color3.fromRGB(255, 255, 255)
        messageLabel.Font = Enum.Font.RobotoMono
        messageLabel.TextSize = 13
        messageLabel.TextXAlignment = Enum.TextXAlignment.Left
        messageLabel.TextWrapped = true
        messageLabel.AutomaticSize = Enum.AutomaticSize.Y
        messageLabel.LayoutOrder = 2
        messageLabel.Parent = entry
        
        -- Add separator line
        local separator = Instance.new("Frame")
        separator.Size = UDim2.new(1, 0, 0, 1)
        separator.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
        separator.BorderSizePixel = 0
        separator.LayoutOrder = 3
        separator.Parent = entry
        
        -- Store entry
        table.insert(win._consoleLog, {
            type = entryType,
            message = message,
            time = os.date("%H:%M:%S"),
            frame = entry
        })
        
        -- Limit entries
        while #win._consoleLog > (win._consoleMaxLines or 200) do
            local oldEntry = table.remove(win._consoleLog, 1)
            if oldEntry.frame and oldEntry.frame.Parent then
                oldEntry.frame:Destroy()
            end
        end
        
        -- Auto scroll to bottom
        if win._consoleAutoScroll then
            task.defer(function()
                win._consoleContent.CanvasPosition = Vector2.new(0, win._consoleContent.AbsoluteCanvasSize.Y)
            end)
        end
    end
    
    function CustomGui:_clearConsole(win)
        win._consoleLog = {}
        if win._consoleContent then
            for _, child in ipairs(win._consoleContent:GetChildren()) do
                if child:IsA("Frame") and child.Name ~= "UIListLayout" then
                    child:Destroy()
                end
            end
        end
        CustomGui:_addConsoleEntry(win, "Info", "Console cleared", Color3.fromRGB(100, 200, 100))
    end
    
    function CustomGui:_copyConsoleLog(win)
        if not win._consoleLog or #win._consoleLog == 0 then
            CustomGui:_addConsoleEntry(win, "Warning", "No console entries to copy", Color3.fromRGB(255, 200, 0))
            return
        end
        
        local lines = {}
        for _, entry in ipairs(win._consoleLog) do
            table.insert(lines, string.format("[%s] %s: %s", entry.time, entry.type, entry.message))
        end
        
        local logText = table.concat(lines, "\n")
        
        if Exec.setclipboard then
            pcall(function()
                Exec.setclipboard(logText)
                CustomGui:_addConsoleEntry(win, "Success", "Console log copied to clipboard (" .. #lines .. " entries)", Color3.fromRGB(100, 255, 100))
            end)
        else
            CustomGui:_addConsoleEntry(win, "Info", "Console log printed to output (" .. #lines .. " entries)", Color3.fromRGB(100, 200, 255))
            print("=== CONSOLE LOG ===")
            print(logText)
            print("=== END LOG ===")
        end
    end    function CustomGui:_toggleESP(win)
        local any = (win._esp and (win._esp.names or win._esp.highlight or win._esp.tracers)) and true or false
        if any and not win._espLoop then
            win._espData = win._espData or {}
            win._espLoop = win:RunLoop("esp-loop", function()
                for _, plr in ipairs(Players:GetPlayers()) do
                    if plr ~= LocalPlayer then
                        local char = plr.Character
                        if char then
                            -- Names (BillboardGui)
                            if win._esp.names then
                                local head = char:FindFirstChild("Head")
                                if head then
                                    local bb = head:FindFirstChild("_CG_Name")
                                    if not bb then
                                        bb = Instance.new("BillboardGui")
                                        bb.Name = "_CG_Name"
                                        bb.Size = UDim2.new(0, 0, 0, 0)
                                        bb.AlwaysOnTop = true
                                        bb.ExtentsOffset = Vector3.new(0, 2.5, 0)
                                        bb.Parent = head
                                        local tl = Instance.new("TextLabel")
                                        tl.Name = "Text"
                                        tl.BackgroundTransparency = 1
                                        tl.Size = UDim2.new(0, 200, 0, 20)
                                        tl.AnchorPoint = Vector2.new(0.5, 0.5)
                                        tl.Position = UDim2.new(0.5, 0, 0.5, 0)
                                        tl.TextScaled = true
                                        tl.Font = Enum.Font.GothamBold
                                        tl.Parent = bb
                                    end
                                    local tl = bb:FindFirstChild("Text")
                                    if tl then
                                        tl.Text = plr.DisplayName or plr.Name
                                        if win._esp.teamColors and plr.Team and plr.TeamColor then
                                            tl.TextColor3 = plr.TeamColor.Color
                                        else
                                            tl.TextColor3 = Color3.fromRGB(255,255,255)
                                        end
                                    end
                                end
                            else
                                local head = char:FindFirstChild("Head")
                                local bb = head and head:FindFirstChild("_CG_Name")
                                if bb then bb:Destroy() end
                            end
                            -- Highlight
                            if win._esp.highlight then
                                local hl = char:FindFirstChildOfClass("Highlight")
                                if not hl then
                                    hl = Instance.new("Highlight")
                                    hl.FillTransparency = 1
                                    hl.OutlineTransparency = 0
                                    hl.Parent = char
                                end
                                if win._esp.teamColors and plr.Team and plr.TeamColor then
                                    hl.OutlineColor = plr.TeamColor.Color
                                else
                                    hl.OutlineColor = Color3.fromRGB(255, 50, 50)
                                end
                            else
                                local hl = char:FindFirstChildOfClass("Highlight")
                                if hl then hl:Destroy() end
                            end
                            -- Tracers (Drawing API if available)
                            if win._esp.tracers and Drawing and typeof(Drawing.new) == "function" then
                                local cam = workspace.CurrentCamera
                                local root = char:FindFirstChild("HumanoidRootPart")
                                if root and cam then
                                    win._espData[plr] = win._espData[plr] or {}
                                    local line = win._espData[plr].line
                                    if not line then
                                        line = Drawing.new("Line")
                                        line.Thickness = 1.5
                                        line.Transparency = 1
                                        win._espData[plr].line = line
                                    end
                                    local from = Vector2.new(cam.ViewportSize.X/2, cam.ViewportSize.Y)
                                    local pos, onScreen = cam:WorldToViewportPoint(root.Position)
                                    if onScreen then
                                        line.Visible = true
                                        line.From = from
                                        line.To = Vector2.new(pos.X, pos.Y)
                                        line.Color = (win._esp.teamColors and plr.Team and plr.TeamColor and plr.TeamColor.Color) or Color3.fromRGB(255, 255, 255)
                                    else
                                        line.Visible = false
                                    end
                                end
                            else
                                -- destroy tracer if exists
                                local d = win._espData and win._espData[plr]
                                if d and d.line and d.line.Remove then pcall(function() d.line:Remove() end) end
                                if d then d.line = nil end
                            end
                        end
                    end
                end
            end, 0.25)
        elseif (not any) and win._espLoop then
            pcall(win._espLoop) -- stop function
            win._espLoop = nil
            -- cleanup adornments
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= LocalPlayer and plr.Character then
                    local head = plr.Character:FindFirstChild("Head")
                    local bb = head and head:FindFirstChild("_CG_Name")
                    if bb then bb:Destroy() end
                    local hl = plr.Character:FindFirstChildOfClass("Highlight")
                    if hl then hl:Destroy() end
                end
            end
            if win._espData then
                for _, d in pairs(win._espData) do
                    if d.line and d.line.Remove then pcall(function() d.line:Remove() end) end
                end
                win._espData = {}
            end
        end
    end

    function CustomGui:_enableNoclip(win, state)
        state = not not state
        if state and not win._noclipConn then
            win._noclipConn = RunService.Stepped:Connect(function()
                local char = LocalPlayer.Character
                if not char then return end
                for _, p in ipairs(char:GetDescendants()) do
                    if p:IsA("BasePart") then p.CanCollide = false end
                end
            end)
            win:RegisterTask("noclip", win._noclipConn)
        elseif (not state) and win._noclipConn then
            pcall(function() win._noclipConn:Disconnect() end)
            win._noclipConn = nil
        end
    end

    function CustomGui:_enableClickTP(win, state, modifierKey)
        state = not not state
        win._clickTPMod = modifierKey or Enum.KeyCode.LeftControl
        if state and not win._clickTPConn then
            local mouse = LocalPlayer:GetMouse()
            win._clickTPConn = mouse.Button1Down:Connect(function()
                if not UIS:IsKeyDown(win._clickTPMod) then return end
                local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not hrp then return end
                local pos = mouse.Hit and mouse.Hit.p
                if pos then
                    hrp.CFrame = CFrame.new(pos + Vector3.new(0, 3, 0))
                end
            end)
            win:RegisterTask("clicktp", win._clickTPConn)
        elseif (not state) and win._clickTPConn then
            pcall(function() win._clickTPConn:Disconnect() end)
            win._clickTPConn = nil
        end
    end

    function CustomGui:_buildGUIFinderTab(win)
        local tab = win:MakeTab({ Name = "GUI Finder" })
        
        -- Store for search history and found elements
        win._guiFinderStore = win._guiFinderStore or win:CreateStore("gui_finder")
        win._lastFound = win._lastFound or {}
        
        CustomGui:AddLabel(tab, "Search for GUI elements in the game")
        
        -- Search input (using a button that prompts for input)
        CustomGui:AddButton(tab, { Name = "Enter Search Term", Callback = function()
            -- Create a simple input GUI
            CustomGui:_createSearchInput(win)
        end })
        
        -- Quick search buttons for common terms
        CustomGui:AddLabel(tab, "Quick Searches:")
        
        local commonSearches = {"Auto", "Wave", "Shop", "Settings", "Menu", "Button", "Toggle", "Upgrade"}
        for _, term in ipairs(commonSearches) do
            CustomGui:AddButton(tab, { Name = "Find: " .. term, Callback = function()
                win._lastFound = CustomGui:_findGUIElement(term)
                CustomGui:_displayFoundElements(win, win._lastFound)
            end })
        end
        
        -- Action buttons
        CustomGui:AddLabel(tab, "Actions on Found Elements:")
        
        for i = 1, 5 do
            CustomGui:AddButton(tab, { Name = "Click Result #" .. i, Callback = function()
                CustomGui:_clickFoundElement(win, i)
            end })
        end
        
        CustomGui:AddLabel(tab, "Copy Paths:")
        
        for i = 1, 5 do
            CustomGui:AddButton(tab, { Name = "Copy Path #" .. i, Callback = function()
                CustomGui:_copyElementPath(win, i)
            end })
        end
        
        CustomGui:AddButton(tab, { Name = "Copy All Paths", Callback = function()
            CustomGui:_copyAllPaths(win)
        end })
        
        -- Clear results
        CustomGui:AddButton(tab, { Name = "Clear Results", Callback = function()
            win._lastFound = {}
            print("Cleared search results")
            Exec.notify("GUI Finder", "Results cleared", 2)
        end })
        
        return tab
    end

    function CustomGui:_buildUtilitiesTab(win)
        local tab = win:MakeTab({ Name = "Utilities" })
        -- Persistent Utilities store
        win._utilitiesStore = win._utilitiesStore or win:CreateStore("utilities")
        local uStore = win._utilitiesStore
        local defaults = {
            antiAFK = false,
            espNames = false,
            espHighlight = false,
            espTracers = false,
            espTeamColors = true,
            noclip = false,
            clickTP = false,
            fpsCap = 60,
            theme = "Carbon",
        }
        local uSettings = uStore:Get("utilities", defaults)
        local function usave() uStore:Set("utilities", uSettings) end

        -- Anti-AFK
        CustomGui:AddToggle(tab, { Name = "Anti-AFK", Default = uSettings.antiAFK, Callback = function(on)
            uSettings.antiAFK = on; usave(); win:EnableAntiAFK(on)
        end })

        -- ESP toggles
        win._esp = win._esp or { names=false, highlight=false, tracers=false, teamColors=true }
        win._esp.names = uSettings.espNames
        win._esp.highlight = uSettings.espHighlight
        win._esp.tracers = uSettings.espTracers
        win._esp.teamColors = uSettings.espTeamColors
        CustomGui:AddToggle(tab, { Name = "ESP Names", Default = uSettings.espNames, Callback = function(on)
            uSettings.espNames = on; usave(); win._esp.names = on; CustomGui:_toggleESP(win)
        end })
        CustomGui:AddToggle(tab, { Name = "ESP Highlight", Default = uSettings.espHighlight, Callback = function(on)
            uSettings.espHighlight = on; usave(); win._esp.highlight = on; CustomGui:_toggleESP(win)
        end })
        local drawingAvail = (Drawing and typeof(Drawing.new) == "function")
        CustomGui:AddToggle(tab, { Name = "ESP Tracers" .. (drawingAvail and "" or " (Unavailable)"), Default = uSettings.espTracers, Callback = function(on)
            if drawingAvail then uSettings.espTracers = on; usave(); win._esp.tracers = on; CustomGui:_toggleESP(win) else Exec.notify("ESP", "Drawing API not available", 3) end
        end })
        CustomGui:AddToggle(tab, { Name = "ESP Team Colors", Default = uSettings.espTeamColors, Callback = function(on)
            uSettings.espTeamColors = on; usave(); win._esp.teamColors = on; CustomGui:_toggleESP(win)
        end })

        -- Noclip & Click TP
        CustomGui:AddToggle(tab, { Name = "Noclip", Default = uSettings.noclip, Callback = function(on)
            uSettings.noclip = on; usave(); CustomGui:_enableNoclip(win, on)
        end })
        CustomGui:AddToggle(tab, { Name = "Click TP (Hold Ctrl)", Default = uSettings.clickTP, Callback = function(on)
            uSettings.clickTP = on; usave(); CustomGui:_enableClickTP(win, on, Enum.KeyCode.LeftControl)
        end })

        -- FPS Cap
        CustomGui:AddSlider(tab, { Name = "FPS Cap", Min = 30, Max = 360, Default = uSettings.fpsCap or 60, Callback = function(v)
            v = math.floor(v)
            uSettings.fpsCap = v; usave(); CustomGui:_setFPS(v)
        end })

        -- Server actions
        CustomGui:AddButton(tab, { Name = "Rejoin", Callback = function()
            pcall(function() TeleportService:Teleport(game.PlaceId, LocalPlayer) end)
        end })
        CustomGui:AddButton(tab, { Name = "Server Hop", Callback = function()
            CustomGui:_serverHop()
        end })
        
        -- GUI Finder utility
        CustomGui:AddButton(tab, { Name = "Find Auto Wave", Callback = function()
            CustomGui:_findGUIElement("Auto Wave")
        end })

        -- Theme as dropdown
        CustomGui:AddLabel(tab, "Theme")
        CustomGui:AddDropdown(tab, {
            Name = "Theme",
            Options = {"Carbon", "Midnight", "Pastel"},
            Default = uSettings.theme or "Carbon",
            Callback = function(val)
                uSettings.theme = val; usave(); CustomGui:_applyThemeToWindow(win, val)
            end
        })
        CustomGui:_applyThemeToWindow(win, uSettings.theme or "Carbon")

        -- Keybinds & Command palette
        CustomGui:_ensureKeybindLoop(win)
        CustomGui:_ensureCommandPalette(win, Enum.KeyCode.F2)
        return tab
    end

    -- Public window APIs
    function CustomGui:BuildUtilitiesTab(win)
        return CustomGui:_buildUtilitiesTab(win)
    end
    
    function CustomGui:BuildGUIFinderTab(win)
        return CustomGui:_buildGUIFinderTab(win)
    end
    
    function CustomGui:BuildRemoteDetectorTab(win)
        return CustomGui:_buildRemoteDetectorTab(win)
    end
    
    function CustomGui:BuildConsoleTab(win)
        return CustomGui:_buildConsoleTab(win)
    end

    function CustomGui:SetTheme(win, name)
        CustomGui:_applyThemeToWindow(win, name)
    end

    function CustomGui:BindKey(win, keyCode, cb)
        CustomGui:_ensureKeybindLoop(win)
        win._keybinds[keyCode] = win._keybinds[keyCode] or {}
        table.insert(win._keybinds[keyCode], cb)
        return function()
            local t = win._keybinds[keyCode]
            if not t then return end
            for i, f in ipairs(t) do if f == cb then table.remove(t, i) break end end
        end
    end
end

return CustomGui
