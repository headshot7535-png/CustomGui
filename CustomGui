-- CustomGui.lua
-- Roblox GUI helper with Delta-executor friendly features, native Anti-AFK,
-- task manager (Stop All), per-game settings, teleport re-exec, and richer controls.
-- Usage: local Gui = require(path_to_CustomGui)

local CustomGui = {}

-- Services and shared locals
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService("HttpService")
local UIS = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local CoreGui = game:GetService("CoreGui")
local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")

-- Themes
local Themes = {
    Carbon = {
        bg = Color3.fromRGB(22,22,22),
        top = Color3.fromRGB(32,32,32),
        tab = Color3.fromRGB(35,35,35),
        tabActive = Color3.fromRGB(60,180,75),
        tabInactive = Color3.fromRGB(50,50,50),
        text = Color3.fromRGB(220,220,220),
        section = Color3.fromRGB(45,45,45),
        buttonOn = Color3.fromRGB(60,180,75),
        buttonOff = Color3.fromRGB(180,60,60),
        sliderBar = Color3.fromRGB(60,60,60),
        sliderThumb = Color3.fromRGB(100,100,255),
        dropdownBG = Color3.fromRGB(38,38,38),
        dropdownOpt = Color3.fromRGB(80,80,80),
    },
    Midnight = {
        bg = Color3.fromRGB(16,18,24),
        top = Color3.fromRGB(20,22,30),
        tab = Color3.fromRGB(24,26,34),
        tabActive = Color3.fromRGB(88,101,242),
        tabInactive = Color3.fromRGB(48,50,60),
        text = Color3.fromRGB(220,225,235),
        section = Color3.fromRGB(28,30,38),
        buttonOn = Color3.fromRGB(88,101,242),
        buttonOff = Color3.fromRGB(190,70,70),
        sliderBar = Color3.fromRGB(60,62,72),
        sliderThumb = Color3.fromRGB(126,137,255),
        dropdownBG = Color3.fromRGB(26,28,36),
        dropdownOpt = Color3.fromRGB(64,66,76),
    },
    Pastel = {
        bg = Color3.fromRGB(235,239,242),
        top = Color3.fromRGB(210,220,230),
        tab = Color3.fromRGB(215,225,235),
        tabActive = Color3.fromRGB(64,180,170),
        tabInactive = Color3.fromRGB(190,200,210),
        text = Color3.fromRGB(24,32,40),
        section = Color3.fromRGB(225,232,238),
        buttonOn = Color3.fromRGB(64,180,170),
        buttonOff = Color3.fromRGB(220,90,90),
        sliderBar = Color3.fromRGB(170,180,190),
        sliderThumb = Color3.fromRGB(64,160,200),
        dropdownBG = Color3.fromRGB(225,232,238),
        dropdownOpt = Color3.fromRGB(200,210,220),
    }
}

local function getThemeFor(inst)
    local sg = inst:FindFirstAncestorOfClass("ScreenGui")
    local name = sg and sg:GetAttribute("ThemeName") or "Carbon"
    return Themes[name] or Themes.Carbon, name or "Carbon"
end

-- Executor/Env utilities with safe fallbacks (Delta-friendly)
local Exec = {}
do
    local ok_identify, identify = pcall(function()
        return (identifyexecutor or identify_executor or getexecutorname)
    end)
    function Exec.identify()
        local name, ver
        if ok_identify and identify then
            local ok, a, b = pcall(function() return identify() end)
            if ok then
                if typeof(a) == "string" and typeof(b) == "string" then name, ver = a, b else name = tostring(a or "Unknown") end
            end
        end
        -- Common globals some executors expose
        if not name then
            if syn then name = "syn" end
            if KRNL_LOADED then name = "krnl" end
            if is_sirhurt_closure then name = "sirhurt" end
            if hookfunction and not name then name = "generic" end
        end
        return name or "unknown", ver
    end

    local function tryf(name)
        local ok, fn = pcall(function() return _G[name] or getfenv()[name] or _G[name] end)
        if ok and typeof(fn) == "function" then return fn end
        if syn and typeof(syn[name]) == "function" then return syn[name] end
        return nil
    end

    Exec.isfile = isfile or tryf("isfile")
    Exec.writefile = writefile or tryf("writefile")
    Exec.readfile = readfile or tryf("readfile")
    Exec.makefolder = makefolder or tryf("makefolder")
    Exec.isfolder = isfolder or tryf("isfolder")
    Exec.queue_on_teleport = queue_on_teleport or (syn and syn.queue_on_teleport) or tryf("queue_on_teleport")
    Exec.protect_gui = (syn and syn.protect_gui) or tryf("protect_gui")
    Exec.gethui = (gethui or get_hidden_ui or gethiddengui or stealth_ui) -- many aliases across executors
    Exec.setclipboard = setclipboard or (syn and syn.write_clipboard) or tryf("setclipboard")

    function Exec.notify(title, text, duration)
        pcall(function()
            StarterGui:SetCore("SendNotification", {Title = title or "CustomGui"; Text = text or ""; Duration = duration or 3})
        end)
    end

    -- Ensure folder exists (noop if FS not available)
    function Exec.ensure_folder(path)
        if not (Exec.isfolder and Exec.makefolder) then return end
        local ok = false
        pcall(function()
            if not Exec.isfolder(path) then Exec.makefolder(path) end
            ok = true
        end)
        return ok
    end
end

-- JSON helpers
local function json_encode(tbl)
    local ok, res = pcall(function() return HttpService:JSONEncode(tbl) end)
    return ok and res or "{}"
end
local function json_decode(str)
    if type(str) ~= "string" then return nil end
    local ok, res = pcall(function() return HttpService:JSONDecode(str) end)
    return ok and res or nil
end

-- UI parent selection (CoreGui/gethui preferred for exploit stability)
local function choose_ui_parent()
    -- Prefer hidden UI layer if provided by the executor
    if Exec.gethui and typeof(Exec.gethui) == "function" then
        local ok, ui = pcall(function() return Exec.gethui() end)
        if ok and typeof(ui) == "Instance" then return ui end
    end
    -- Try CoreGui (exploit)
    local ok = pcall(function() return CoreGui.Name end)
    if ok then return CoreGui end
    -- Fallback to PlayerGui (normal LocalScript context)
    local pg = LocalPlayer:FindFirstChildOfClass("PlayerGui") or LocalPlayer:WaitForChild("PlayerGui")
    return pg
end

function CustomGui:CreateWindow(props)
    props = props or {}
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = props.Name or "CustomWindow"
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    screenGui.DisplayOrder = 1_000_000 -- always on top
    screenGui:SetAttribute("ThemeName", props.Theme or "Carbon")
    screenGui:SetAttribute("Density", props.Density or "comfortable") -- comfortable | compact
    -- Protect and parent to executor UI if possible
    pcall(function() if Exec.protect_gui then Exec.protect_gui(screenGui) end end)
    screenGui.Parent = choose_ui_parent()

    -- Main frame
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0.7, 0, 0.7, 0)
    mainFrame.Position = UDim2.new(0.15, 0, 0.15, 0)
    local theme = getThemeFor(screenGui)
    mainFrame.BackgroundColor3 = theme.bg
    mainFrame.BorderSizePixel = 0
    mainFrame.BackgroundTransparency = 0.05
    mainFrame.Parent = screenGui
    mainFrame.ClipsDescendants = true
    mainFrame.AnchorPoint = Vector2.new(0,0)
    mainFrame.ZIndex = 1

    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 18)
    uiCorner.Parent = mainFrame

    -- Top bar (draggable, closable)
    local topBar = Instance.new("Frame")
    topBar.Name = "TopBar"
    local density = screenGui:GetAttribute("Density")
    local topH = (density == "compact") and 30 or 36
    topBar.Size = UDim2.new(1, 0, 0, topH)
    topBar.Position = UDim2.new(0, 0, 0, 0)
    topBar.BackgroundColor3 = theme.top
    topBar.Parent = mainFrame
    local topCorner = Instance.new("UICorner")
    topCorner.CornerRadius = UDim.new(0, 18)
    topCorner.Parent = topBar

    -- Drag shield (prevents accidental clicks on controls while dragging the window)
    local dragShield = Instance.new("Frame")
    dragShield.Name = "DragShield"
    dragShield.BackgroundTransparency = 1
    dragShield.Active = true
    dragShield.Visible = false
    dragShield.ZIndex = 999
    dragShield.Size = UDim2.new(1, 0, 1, 0)
    dragShield.Position = UDim2.new(0, 0, 0, 0)
    dragShield.Parent = mainFrame

    local title = Instance.new("TextLabel")
    title.Text = props.Name or "CustomWindow"
    title.Size = UDim2.new(1, -80, 1, 0)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.BackgroundTransparency = 1
    title.TextColor3 = theme.text
    title.Font = Enum.Font.GothamBold
    title.TextSize = 20
    title.Parent = topBar
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.TextWrapped = true

    local closeBtn = Instance.new("TextButton")
    closeBtn.Text = "❌"
    closeBtn.Size = UDim2.new(0, 36, 1, 0)
    closeBtn.Position = UDim2.new(1, -36, 0, 0)
    closeBtn.BackgroundTransparency = 1
    closeBtn.TextColor3 = Color3.fromRGB(255,0,0)
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.TextSize = 28
    closeBtn.Parent = topBar
    closeBtn.ZIndex = 2

    -- Minimize button
    local minimizeBtn = Instance.new("TextButton")
    minimizeBtn.Text = "_"
    minimizeBtn.Size = UDim2.new(0, 36, 1, 0)
    minimizeBtn.Position = UDim2.new(1, -72, 0, 0)
    minimizeBtn.BackgroundTransparency = 1
    minimizeBtn.TextColor3 = Color3.fromRGB(180,180,180)
    minimizeBtn.Font = Enum.Font.GothamBold
    minimizeBtn.TextSize = 24
    minimizeBtn.Parent = topBar
    minimizeBtn.ZIndex = 2

    -- Floating reopen button
    local reopenBtn = Instance.new("TextButton")
    reopenBtn.Text = "☰"
    reopenBtn.Size = UDim2.new(0, 44, 0, 44)
    reopenBtn.Position = UDim2.new(0, 14, 0, 14)
    reopenBtn.BackgroundColor3 = Color3.fromRGB(32,32,32)
    reopenBtn.TextColor3 = Color3.fromRGB(255,255,255)
    reopenBtn.Font = Enum.Font.GothamBold
    reopenBtn.TextSize = 28
    reopenBtn.Visible = false
    reopenBtn.Parent = screenGui
    reopenBtn.ZIndex = 100 -- keep on top of other UI
    local reopenCorner = Instance.new("UICorner")
    reopenCorner.CornerRadius = UDim.new(0, 14)
    reopenCorner.Parent = reopenBtn

    -- Ensure the reopen icon is at least partially visible when shown
    local function ensureReopenVisible()
        local scr = screenGui.AbsoluteSize
        local btn = reopenBtn.AbsoluteSize
        local pos = reopenBtn.AbsolutePosition
        
        -- Only clamp if completely off-screen, allow partial off-screen positioning
        local nx = pos.X
        local ny = pos.Y
        
        -- If completely off the right, bring it back partially
        if pos.X >= scr.X then
            nx = scr.X - math.min(btn.X, 44) -- Show at least 44px or full button width
        end
        -- If completely off the left, bring it back partially  
        if pos.X + btn.X <= 0 then
            nx = -btn.X + math.min(btn.X, 44)
        end
        -- If completely off the bottom, bring it back partially
        if pos.Y >= scr.Y then
            ny = scr.Y - math.min(btn.Y, 44)
        end
        -- If completely off the top, bring it back partially
        if pos.Y + btn.Y <= 0 then
            ny = -btn.Y + math.min(btn.Y, 44)
        end
        
        if nx ~= pos.X or ny ~= pos.Y then
            reopenBtn.Position = UDim2.new(0, nx, 0, ny)
        end
    end

    -- Optional keybind to show/hide (RightShift default)
    local toggleKey = props.ToggleKey or Enum.KeyCode.RightShift
    UIS.InputBegan:Connect(function(input, gp)
        if gp then return end
        if input.KeyCode == toggleKey then
            if mainFrame.Visible then
                mainFrame.Visible = false
                reopenBtn.Visible = true
                dragShield.Visible = false
                ensureReopenVisible()
            else
                mainFrame.Visible = true
                reopenBtn.Visible = false
            end
        end
    end)

    -- window object exposed to caller
    local windowObj = {
        ScreenGui = screenGui,
        mainFrame = mainFrame,
        closeBtn = closeBtn,
        minimizeBtn = minimizeBtn,
        reopenBtn = reopenBtn,
        _closeCb = nil,
        _tasks = {},
        _stopAllFlag = false,
        _antiAFKConn = nil,
        _antiAFKEnabled = false,
        _antiAFKGui = nil,
        _antiAFKDot = nil,
        _store = nil,
    }

    function windowObj:SetCloseCallback(cb)
        self._closeCb = cb
    end

    function windowObj:Show()
        if self.ScreenGui then self.ScreenGui.Enabled = true end
        if self.mainFrame then self.mainFrame.Visible = true end
        if self.reopenBtn then self.reopenBtn.Visible = false end
    end

    function windowObj:Hide()
        if self.mainFrame then self.mainFrame.Visible = false end
        if self.ScreenGui then self.ScreenGui.Enabled = true end
        dragShield.Visible = false
        
        -- Force the reopen button to be visible and ensure it's on screen
        if self.reopenBtn then 
            self.reopenBtn.Visible = true
            ensureReopenVisible()
            -- Double-check visibility
            task.defer(function()
                if self.reopenBtn then
                    self.reopenBtn.Visible = true
                    print("Hide - Reopen icon position:", self.reopenBtn.AbsolutePosition)
                end
            end)
        end
        
        if self._closeCb then pcall(self._closeCb) end
    end

    function windowObj:Destroy()
        -- Ensure everything is stopped and cleaned
        self:StopAll()
        if self._closeCb then pcall(self._closeCb) end
        if self._cmdGui then pcall(function() self._cmdGui:Destroy() end); self._cmdGui = nil; self._cmdBox = nil end
        if self._antiAFKGui then pcall(function() self._antiAFKGui:Destroy() end); self._antiAFKGui = nil; self._antiAFKDot = nil end
        if self.ScreenGui then self.ScreenGui:Destroy() end
    end

    -- Task manager: register, run loop, and Stop All
    function windowObj:RegisterTask(id, ref)
        self._tasks[id] = ref
    end
    function windowObj:UnregisterTask(id)
        self._tasks[id] = nil
    end
    function windowObj:RunLoop(id, fn, interval)
        local alive = true
        local th = task.spawn(function()
            while alive and not self._stopAllFlag do
                local ok, err = pcall(fn)
                if not ok then warn("CustomGui loop error ["..tostring(id).."]:", err) end
                task.wait(interval or 0.5)
            end
        end)
        self:RegisterTask(id, {type="thread", thread = th, cancel = function() alive = false; pcall(task.cancel, th) end})
        return function() -- stop fn
            alive = false; self:UnregisterTask(id)
            pcall(task.cancel, th)
        end
    end
    function windowObj:StopAll()
        self._stopAllFlag = true
        for id, ref in pairs(self._tasks) do
            local t = typeof(ref)
            if t == "thread" then pcall(task.cancel, ref)
            elseif t == "RBXScriptConnection" then pcall(function() ref:Disconnect() end)
            elseif type(ref) == "table" and typeof(ref.thread) == "thread" then
                if type(ref.cancel) == "function" then pcall(ref.cancel) else pcall(task.cancel, ref.thread) end
            elseif type(ref) == "function" then pcall(ref) end
            self._tasks[id] = nil
        end
        -- Disable Anti-AFK if running
        self:EnableAntiAFK(false)
        -- Utilities cleanup: noclip, click TP
        if self._noclipConn then pcall(function() self._noclipConn:Disconnect() end); self._noclipConn = nil end
        if self._clickTPConn then pcall(function() self._clickTPConn:Disconnect() end); self._clickTPConn = nil end
        -- ESP cleanup: set flags false and call toggle to perform teardown
        if self._esp then self._esp.names=false; self._esp.highlight=false; self._esp.tracers=false end
        pcall(function() CustomGui:_toggleESP(self) end)
    end

    -- Native Anti-AFK with indicator dot (top-left)
    function windowObj:_ensureAFKGui()
        if self._antiAFKGui then return end
        local g = Instance.new("ScreenGui")
        g.Name = "AFKIndicator"
        g.IgnoreGuiInset = true
        g.ResetOnSpawn = false
        g.DisplayOrder = 1_000_000
        pcall(function() if Exec.protect_gui then Exec.protect_gui(g) end end)
        g.Parent = choose_ui_parent()
        local dot = Instance.new("Frame")
        dot.Name = "Dot"
        dot.Size = UDim2.new(0, 12, 0, 12)
        dot.Position = UDim2.new(0, 8, 0, 8)
        dot.BackgroundColor3 = Color3.fromRGB(0, 200, 0)
        dot.BorderSizePixel = 0
        dot.Parent = g
        local dcorner = Instance.new("UICorner")
        dcorner.CornerRadius = UDim.new(1, 0)
        dcorner.Parent = dot
        self._antiAFKGui = g
        self._antiAFKDot = dot
        dot.Visible = false
    end
    function windowObj:EnableAntiAFK(state)
        state = not not state
        self:_ensureAFKGui()
        if state and not self._antiAFKEnabled then
            local VirtualUser = game:GetService("VirtualUser")
            self._antiAFKConn = LocalPlayer.Idled:Connect(function()
                pcall(function()
                    VirtualUser:CaptureController()
                    VirtualUser:ClickButton2(Vector2.new())
                end)
            end)
            self._antiAFKEnabled = true
            if self._antiAFKDot then self._antiAFKDot.Visible = true end
            Exec.notify("Anti-AFK", "Enabled", 2)
        elseif (not state) and self._antiAFKEnabled then
            if self._antiAFKConn then pcall(function() self._antiAFKConn:Disconnect() end) end
            self._antiAFKConn = nil
            self._antiAFKEnabled = false
            if self._antiAFKDot then self._antiAFKDot.Visible = false end
            Exec.notify("Anti-AFK", "Disabled", 2)
        end
    end
    -- Optional default from props
    if props.AntiAFKDefault then windowObj:EnableAntiAFK(true) end

    -- Settings store (per-user/per-game paths if FS exists)
    function windowObj:CreateStore(name, opts)
        opts = opts or {}
        local userId = tostring(LocalPlayer.UserId or "0")
        local placeId = tostring(game.PlaceId or "0")
        local base = opts.base or "CustomGui"
        local perUser = (opts.perUser ~= false)
        local perGame = (opts.perGame ~= false)
        local parts = {base}
        if perUser then table.insert(parts, userId) end
        if perGame then table.insert(parts, placeId) end
        local folder = table.concat(parts, "/")
        local file = folder .. "/" .. (name or "settings") .. ".json"
        local function ensure()
            if not Exec.ensure_folder then return end
            local accum = {}
            for seg in string.gmatch(folder, "[^/]+") do
                table.insert(accum, seg)
                Exec.ensure_folder(table.concat(accum, "/"))
            end
        end
        ensure()
        local cache = {}
        local function save()
            if not Exec.writefile then return end
            local ok = pcall(function() Exec.writefile(file, json_encode(cache)) end)
            if not ok then warn("CustomGui: failed to write settings "..file) end
        end
        local function load()
            if not (Exec.isfile and Exec.readfile) then return end
            local ok, str = pcall(function()
                if Exec.isfile(file) then return Exec.readfile(file) end
            end)
            if ok and type(str) == "string" then
                local got = json_decode(str)
                if type(got) == "table" then cache = got end
            end
        end
        load()
        local store = {}
        function store:Get(k, default)
            local v = cache[k]
            if v == nil then return default end
            return v
        end
        function store:Set(k, v)
            cache[k] = v
            save()
        end
        function store:All() return cache end
        function store:Save() save() end
        function store:Load() load() end
        self._store = store
        return store
    end

    -- Draggable reopen button with persisted position (initialized after CreateStore is available)
    do
        windowObj._uiStore = windowObj:CreateStore("ui")
        -- Apply saved window position (pixels) if exists
        local function applySavedWindowPos()
            local saved = windowObj._uiStore and windowObj._uiStore:Get("windowPos")
            if type(saved) == "table" then
                if typeof(saved.ox) == "number" and typeof(saved.oy) == "number" then
                    mainFrame.Position = UDim2.new(0, saved.ox, 0, saved.oy)
                elseif typeof(saved.sx) == "number" and typeof(saved.sy) == "number" then
                    -- Backward compatibility for normalized saved values
                    local scr = screenGui.AbsoluteSize
                    local fr = mainFrame.AbsoluteSize
                    local x = saved.sx * math.max(0, scr.X - fr.X)
                    local y = saved.sy * math.max(0, scr.Y - fr.Y)
                    mainFrame.Position = UDim2.new(0, math.floor(x + 0.5), 0, math.floor(y + 0.5))
                end
            end
        end
        task.defer(applySavedWindowPos)
        screenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(applySavedWindowPos)
        local function applySavedReopenPos()
            local saved = windowObj._uiStore and windowObj._uiStore:Get("reopenPos")
            if type(saved) == "table" then
                if typeof(saved.ox) == "number" and typeof(saved.oy) == "number" then
                    reopenBtn.Position = UDim2.new(0, saved.ox, 0, saved.oy)
                elseif typeof(saved.sx) == "number" and typeof(saved.sy) == "number" then
                    -- Backward compatible with older normalized positions
                    local scr = screenGui.AbsoluteSize
                    local btn = reopenBtn.AbsoluteSize
                    local x = saved.sx * math.max(0, scr.X - btn.X)
                    local y = saved.sy * math.max(0, scr.Y - btn.Y)
                    reopenBtn.Position = UDim2.new(0, math.floor(x + 0.5), 0, math.floor(y + 0.5))
                end
            end
            ensureReopenVisible()
        end
        task.defer(applySavedReopenPos)
        screenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(applySavedReopenPos)

        -- Simple reopen icon drag system (same as main window)
        local rDragging, rPending, rDragInput, rDragStart, rStartPos
        local rMovedMag = 0
        local REOPEN_DRAG_SLOP = 8 -- pixels of movement before we consider it a drag
        
        local function saveReopenPos()
            if not windowObj._uiStore then return end
            local pos = reopenBtn.AbsolutePosition
            -- Save raw pixel offsets for exact placement (no clamping)
            windowObj._uiStore:Set("reopenPos", { ox = pos.X, oy = pos.Y })
        end
        
        local function beginReopenDrag(input)
            rDragging = true
            rPending = false
            rDragStart = input.Position
            rStartPos = reopenBtn.AbsolutePosition
            rMovedMag = 0
            if input.UserInputType == Enum.UserInputType.Touch then
                rDragInput = input
            else
                rDragInput = nil
            end
        end
        
        local function endReopenDrag()
            if rDragging or rPending then
                local wasDragging = rDragging
                rDragging = false
                rPending = false
                if wasDragging then
                    saveReopenPos()
                else
                    -- Was just a click - open the main window
                    mainFrame.Visible = true
                    reopenBtn.Visible = false
                    dragShield.Visible = false
                end
            end
        end
        
        local function updateReopenDrag(input)
            if not rDragging then
                if not rPending then return end
                local delta = Vector2.new(input.Position.X - rDragStart.X, input.Position.Y - rDragStart.Y)
                rMovedMag = math.max(rMovedMag, delta.Magnitude)
                if rMovedMag >= REOPEN_DRAG_SLOP then
                    beginReopenDrag(input)
                else
                    return
                end
            end
            
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                local delta = Vector2.new(input.Position.X - rDragStart.X, input.Position.Y - rDragStart.Y)
                rMovedMag = math.max(rMovedMag, delta.Magnitude)
                local newAbs = Vector2.new(rStartPos.X + delta.X, rStartPos.Y + delta.Y)
                reopenBtn.Position = UDim2.new(0, newAbs.X, 0, newAbs.Y)
            elseif input.UserInputType == Enum.UserInputType.Touch then
                if (rDragInput == nil) or (input == rDragInput) then
                    local delta = input.Position - rDragStart
                    rMovedMag = math.max(rMovedMag, delta.Magnitude)
                    local newAbs = Vector2.new(rStartPos.X + delta.X, rStartPos.Y + delta.Y)
                    reopenBtn.Position = UDim2.new(0, newAbs.X, 0, newAbs.Y)
                end
            end
        end
        
        reopenBtn.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                rPending = true
                rDragging = false
                rDragStart = input.Position
                rStartPos = reopenBtn.AbsolutePosition
                rMovedMag = 0
                if input.UserInputType == Enum.UserInputType.Touch then 
                    rDragInput = input 
                else 
                    rDragInput = nil 
                end
            end
        end)
        
        reopenBtn.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                updateReopenDrag(input)
            end
        end)
        
        UIS.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                updateReopenDrag(input)
            end
        end)
        
        reopenBtn.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                endReopenDrag()
            end
        end)
        
        UIS.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                endReopenDrag()
            end
        end)
    end

    -- Teleport re-exec helper
    function windowObj:QueueOnTeleport(luaSource)
        if not Exec.queue_on_teleport then return false end
        local ok = pcall(function() Exec.queue_on_teleport(luaSource) end)
        return ok
    end

    closeBtn.MouseButton1Click:Connect(function()
        -- X should completely stop and destroy the GUI
        windowObj:StopAll()
        windowObj:Destroy()
    end)
    minimizeBtn.MouseButton1Click:Connect(function()
        mainFrame.Visible = false
        dragShield.Visible = false
        
        -- Force the reopen button to be visible and ensure it's on screen
        reopenBtn.Visible = true
        ensureReopenVisible()
        
        -- Double-check visibility after a short delay (for any rendering issues)
        task.wait(0.1)
        reopenBtn.Visible = true
        
        print("Minimized - Reopen icon position:", reopenBtn.AbsolutePosition)
    end)
    -- MouseButton1Click is handled in InputEnded above to avoid triggering when dragging

    -- Dragging logic: instant threshold-based drag from anywhere
    local wDragging, wPending, wDragInput, wDragStart, wStartPos
    local wMovedMag = 0
    local DRAG_SLOP = 6 -- pixels of movement before we consider it a drag
    local function saveWindowPos()
        if not windowObj._uiStore then return end
        local pos = mainFrame.AbsolutePosition
        windowObj._uiStore:Set("windowPos", { ox = pos.X, oy = pos.Y })
    end
    local function beginWindowDrag(input)
        wDragging = true
        wPending = false
        wDragStart = input.Position
        wStartPos = mainFrame.AbsolutePosition
        wMovedMag = 0
        dragShield.Visible = true
        if input.UserInputType == Enum.UserInputType.Touch then
            wDragInput = input
        else
            wDragInput = nil
        end
    end
    local function endWindowDrag()
        if wDragging or wPending then
            wDragging = false
            wPending = false
            dragShield.Visible = false
            saveWindowPos()
        end
    end
    local function updateDrag(input)
        if not wDragging then
            if not wPending then return end
            local delta = Vector2.new(input.Position.X - wDragStart.X, input.Position.Y - wDragStart.Y)
            wMovedMag = math.max(wMovedMag, delta.Magnitude)
            if wMovedMag >= DRAG_SLOP then
                beginWindowDrag(input)
            else
                return
            end
        end
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = Vector2.new(input.Position.X - wDragStart.X, input.Position.Y - wDragStart.Y)
            wMovedMag = math.max(wMovedMag, delta.Magnitude)
            local newAbs = Vector2.new(wStartPos.X + delta.X, wStartPos.Y + delta.Y)
            mainFrame.Position = UDim2.new(0, newAbs.X, 0, newAbs.Y)
        elseif input.UserInputType == Enum.UserInputType.Touch then
            if (wDragInput == nil) or (input == wDragInput) then
                local delta = input.Position - wDragStart
                wMovedMag = math.max(wMovedMag, delta.Magnitude)
                local newAbs = Vector2.new(wStartPos.X + delta.X, wStartPos.Y + delta.Y)
                mainFrame.Position = UDim2.new(0, newAbs.X, 0, newAbs.Y)
            end
        end
    end
    mainFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            wPending = true
            wDragging = false
            wDragStart = input.Position
            wStartPos = mainFrame.AbsolutePosition
            wMovedMag = 0
            if input.UserInputType == Enum.UserInputType.Touch then wDragInput = input else wDragInput = nil end
        end
    end)
    mainFrame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            updateDrag(input)
        end
    end)
    UIS.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            updateDrag(input)
        end
    end)
    mainFrame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            endWindowDrag()
        end
    end)
    UIS.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            endWindowDrag()
        end
    end)

    -- Tab bar
    local tabBar = Instance.new("Frame")
    tabBar.Name = "TabBar"
    local tabH = (density == "compact") and 32 or 38
    tabBar.Size = UDim2.new(1, 0, 0, tabH)
    tabBar.Position = UDim2.new(0, 0, 0, topH + 4)
    tabBar.BackgroundColor3 = theme.tab
    tabBar.Parent = mainFrame
    local tabCorner = Instance.new("UICorner")
    tabCorner.CornerRadius = UDim.new(0, 12)
    tabCorner.Parent = tabBar

    local tabLayout = Instance.new("UIListLayout")
    tabLayout.Parent = tabBar
    tabLayout.FillDirection = Enum.FillDirection.Horizontal
    tabLayout.Padding = UDim.new(0, 8)
    tabLayout.SortOrder = Enum.SortOrder.LayoutOrder

    -- Tabs storage
    local tabs = {}
    local tabContents = {}
    local activeTab = nil

    function CustomGui:MakeTab(tabProps)
        local tabBtn = Instance.new("TextButton")
        tabBtn.Text = tabProps.Name or "Tab"
    tabBtn.Size = UDim2.new(0, (density == "compact") and 100 or 120, 1, (density == "compact") and -6 or -8)
        tabBtn.BackgroundColor3 = theme.tabInactive
        tabBtn.TextColor3 = theme.text
        tabBtn.Font = Enum.Font.GothamBold
    tabBtn.TextSize = (density == "compact") and 16 or 18
        tabBtn.Parent = tabBar
        tabBtn.AutoButtonColor = true
        local btnCorner = Instance.new("UICorner")
        btnCorner.CornerRadius = UDim.new(0, 8)
        btnCorner.Parent = tabBtn

    local tabContent = Instance.new("ScrollingFrame")
        tabContent.Name = tabProps.Name .. "_Content"
    local padTop = topH + tabH + 8
    tabContent.Size = UDim2.new(1, -8, 1, -padTop - 8)
    tabContent.Position = UDim2.new(0, 4, 0, padTop)
        tabContent.CanvasSize = UDim2.new(0, 0, 0, 800)
    tabContent.ScrollBarThickness = (density == "compact") and 8 or 10
        tabContent.BackgroundTransparency = 1
        tabContent.Parent = mainFrame
        tabContent.AutomaticCanvasSize = Enum.AutomaticSize.Y
        tabContent.ScrollingDirection = Enum.ScrollingDirection.Y
        tabContent.Visible = false

        local layout = Instance.new("UIListLayout")
        layout.Parent = tabContent
    layout.Padding = UDim.new(0, (density == "compact") and 10 or 18)
        layout.SortOrder = Enum.SortOrder.LayoutOrder

        tabs[#tabs+1] = tabBtn
        tabContents[#tabContents+1] = tabContent

        tabBtn.MouseButton1Click:Connect(function()
            for i, t in ipairs(tabContents) do
                t.Visible = false
                tabs[i].BackgroundColor3 = theme.tabInactive
            end
            tabContent.Visible = true
            tabBtn.BackgroundColor3 = theme.tabActive
            activeTab = tabContent
        end)

        if #tabs == 1 then
            tabBtn.BackgroundColor3 = theme.tabActive
            tabContent.Visible = true
            activeTab = tabContent
        end

        return tabContent
    end

    function windowObj:MakeTab(tabProps)
        return CustomGui:MakeTab(tabProps)
    end
    return windowObj
end

function CustomGui:CreateTab(parent, props)
    -- Just return parent (scroll) for simplicity, all controls go in scroll
    return parent
end

function CustomGui:AddSection(parent, props)
    local section = Instance.new("Frame")
    local theme = getThemeFor(parent)
    local sg = parent:FindFirstAncestorOfClass("ScreenGui")
    local density = sg and sg:GetAttribute("Density") or "comfortable"
    section.Size = UDim2.new(0.98, 0, 0, (density == "compact") and 38 or 44)
    section.BackgroundColor3 = theme.section
    section.BackgroundTransparency = 0.15
    section.Parent = parent
    section.LayoutOrder = parent:GetChildren() and #parent:GetChildren() or 1
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 12)
    uiCorner.Parent = section
    local label = Instance.new("TextLabel")
    label.Text = props.Name or "Section"
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = theme.text
    label.Font = Enum.Font.GothamBold
    label.TextSize = (density == "compact") and 20 or 24
    label.Parent = section
    label.AnchorPoint = Vector2.new(0.5,0.5)
    label.Position = UDim2.new(0.5,0,0.5,0)
    return section
end

function CustomGui:AddLabel(parent, text)
    local label = Instance.new("TextLabel")
    label.Text = text
    local sg = parent:FindFirstAncestorOfClass("ScreenGui")
    local density = sg and sg:GetAttribute("Density") or "comfortable"
    label.Size = UDim2.new(0.98, 0, 0, (density == "compact") and 22 or 28)
    label.BackgroundTransparency = 1
    local theme = getThemeFor(parent)
    label.TextColor3 = theme.text
    label.Font = Enum.Font.Gotham
    label.TextSize = 18
    label.Parent = parent
    label.LayoutOrder = parent:GetChildren() and #parent:GetChildren() or 1
    return label
end

-- Collapsible grouped section (top-level definition)
function CustomGui:AddGroup(parent, props)
    local theme = getThemeFor(parent)
    local sg = parent:FindFirstAncestorOfClass("ScreenGui")
    local density = sg and sg:GetAttribute("Density") or "comfortable"
    local group = Instance.new("Frame")
    group.Name = (props.Name or "Group") .. "_Group"
    group.Size = UDim2.new(0.98, 0, 0, 40)
    group.AutomaticSize = Enum.AutomaticSize.Y
    group.BackgroundColor3 = theme.section
    group.BackgroundTransparency = 0.1
    group.Parent = parent
    group.LayoutOrder = parent:GetChildren() and #parent:GetChildren() or 1
    local corner = Instance.new("UICorner"); corner.CornerRadius = UDim.new(0, 10); corner.Parent = group
    local header = Instance.new("TextButton")
    header.Size = UDim2.new(1, -8, 0, (density == "compact") and 30 or 36)
    header.Position = UDim2.new(0, 4, 0, 2)
    header.BackgroundTransparency = 1
    header.Text = (props.Name or "Group") .. "  ▾"
    header.TextXAlignment = Enum.TextXAlignment.Left
    header.TextColor3 = theme.text
    header.Font = Enum.Font.GothamBold
    header.TextSize = (density == "compact") and 18 or 20
    header.Parent = group
    local content = Instance.new("Frame")
    content.Name = "Content"
    content.Size = UDim2.new(1, -8, 0, 0)
    content.AutomaticSize = Enum.AutomaticSize.Y
    content.Position = UDim2.new(0, 4, 0, (density == "compact") and 32 or 38)
    content.BackgroundTransparency = 1
    content.Parent = group
    local list = Instance.new("UIListLayout")
    list.Parent = content
    list.Padding = UDim.new(0, (density == "compact") and 6 or 10)
    list.SortOrder = Enum.SortOrder.LayoutOrder
    local collapsed = false
    header.MouseButton1Click:Connect(function()
        collapsed = not collapsed
        header.Text = (props.Name or "Group") .. (collapsed and "  ▸" or "  ▾")
        content.Visible = not collapsed
    end)
    function group:GetContent() return content end
    return group
end

function CustomGui:AddButton(parent, props)
    local theme = getThemeFor(parent)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0.98, 0, 0, 36)
    btn.Text = props.Name or "Button"
    btn.BackgroundColor3 = theme.tabInactive
    btn.TextColor3 = theme.text
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 18
    btn.Parent = parent
    btn.LayoutOrder = parent:GetChildren() and #parent:GetChildren() or 1
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = btn
    btn.MouseButton1Click:Connect(function()
        if props.Callback then props.Callback() end
    end)
    return btn
end

function CustomGui:AddToggle(parent, props)
    local button = Instance.new("TextButton")
    button.Text = props.Name or "Toggle"
    button.Size = UDim2.new(0.98, 0, 0, 36)
    local theme = getThemeFor(parent)
    button.BackgroundColor3 = theme.buttonOn
    button.TextColor3 = Color3.fromRGB(255,255,255)
    button.Font = Enum.Font.GothamBold
    button.TextSize = 20
    button.Parent = parent
    button.LayoutOrder = parent:GetChildren() and #parent:GetChildren() or 1
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, 8)
    uiCorner.Parent = button
    local state = props.Default or false
    -- store state as attribute for observability (no custom members on Instance)
    pcall(function() button:SetAttribute("CG_State", state) end)
    -- Immediately call the callback with the default value and set visuals
    button.BackgroundColor3 = state and theme.buttonOn or theme.buttonOff
    if props.Callback then props.Callback(state) end
    button.MouseButton1Click:Connect(function()
        state = not state
        pcall(function() button:SetAttribute("CG_State", state) end)
        button.BackgroundColor3 = state and theme.buttonOn or theme.buttonOff
        if props.Callback then props.Callback(state) end
    end)
    return button
end

function CustomGui:AddSlider(parent, props)
    local sliderFrame = Instance.new("Frame")
    sliderFrame.Size = UDim2.new(0.98, 0, 0, 44)
    sliderFrame.BackgroundTransparency = 1
    sliderFrame.Parent = parent
    sliderFrame.LayoutOrder = parent:GetChildren() and #parent:GetChildren() or 1

    local label = Instance.new("TextLabel")
    label.Text = props.Name .. ": " .. tostring(props.Default or props.Min)
    local sg = parent:FindFirstAncestorOfClass("ScreenGui")
    local density = sg and sg:GetAttribute("Density") or "comfortable"
    label.Size = UDim2.new(1, 0, 0, (density == "compact") and 16 or 18)
    label.Position = UDim2.new(0, 0, 0, 0)
    label.BackgroundTransparency = 1
    local theme = getThemeFor(parent)
    label.TextColor3 = theme.text
    label.Font = Enum.Font.Gotham
    label.TextSize = 16
    label.Parent = sliderFrame

    local bar = Instance.new("Frame")
    bar.Size = UDim2.new(0.92, 0, 0, (density == "compact") and 6 or 8)
    bar.Position = UDim2.new(0.04, 0, 0, (density == "compact") and 22 or 26)
    bar.BackgroundColor3 = theme.sliderBar
    bar.Parent = sliderFrame
    local barCorner = Instance.new("UICorner")
    barCorner.CornerRadius = UDim.new(0, 4)
    barCorner.Parent = bar

    local thumb = Instance.new("Frame")
    thumb.Size = UDim2.new(0, (density == "compact") and 14 or 18, 0, (density == "compact") and 14 or 18)
    thumb.Position = UDim2.new(0, 0, 0, (density == "compact") and -4 or -5)
    thumb.BackgroundColor3 = theme.sliderThumb
    thumb.Parent = bar
    local thumbCorner = Instance.new("UICorner")
    thumbCorner.CornerRadius = UDim.new(0, 9)
    thumbCorner.Parent = thumb

    local value = props.Default or props.Min
    local min, max = props.Min, props.Max
    local dragging = false
    local changedCb = nil

    local function setValue(newValue)
        value = math.clamp(newValue, min, max)
        local percent = (value - min) / (max - min)
        thumb.Position = UDim2.new(percent, -9, 0, -5)
        label.Text = props.Name .. ": " .. string.format("%.2f", value)
        if props.Callback then props.Callback(value) end
        if changedCb then pcall(changedCb, value) end
    end
    setValue(value)

    thumb.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
        end
    end)
    thumb.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)
    bar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            local x = input.Position.X - bar.AbsolutePosition.X
            local percent = math.clamp(x / bar.AbsoluteSize.X, 0, 1)
            setValue(min + percent * (max - min))
        end
    end)
    game:GetService("UserInputService").InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local x = input.Position.X - bar.AbsolutePosition.X
            local percent = math.clamp(x / bar.AbsoluteSize.X, 0, 1)
            setValue(min + percent * (max - min))
        end
    end)
    -- expose current value as attribute for simple external reads
    pcall(function() sliderFrame:SetAttribute("CG_Value", value) end)
    -- remove custom methods on Instance to avoid 'not a valid member'
    return sliderFrame
end

function CustomGui:AddMultiDropdown(parent, props)
    local frame = Instance.new("Frame")
    local theme = getThemeFor(parent)
    local sg = parent:FindFirstAncestorOfClass("ScreenGui")
    local density = sg and sg:GetAttribute("Density") or "comfortable"
    frame.Size = UDim2.new(0.98, 0, 0, 0)
    frame.AutomaticSize = Enum.AutomaticSize.Y
    frame.BackgroundColor3 = theme.dropdownBG
    frame.BackgroundTransparency = 0.18
    frame.ClipsDescendants = true
    frame.Parent = parent
    frame.LayoutOrder = parent:GetChildren() and #parent:GetChildren() or 1
    local uiCorner = Instance.new("UICorner"); uiCorner.CornerRadius = UDim.new(0, 8); uiCorner.Parent = frame
    local pad = Instance.new("UIPadding"); pad.PaddingLeft = UDim.new(0,4); pad.PaddingRight = UDim.new(0,4); pad.PaddingTop = UDim.new(0,6); pad.PaddingBottom = UDim.new(0,6); pad.Parent = frame
    local stack = Instance.new("UIListLayout"); stack.Parent = frame; stack.Padding = UDim.new(0, (density=="compact") and 4 or 6); stack.SortOrder = Enum.SortOrder.LayoutOrder

    local header = Instance.new("TextButton")
    header.Text = (props.Name or "Dropdown") .. "  ▾"
    header.Size = UDim2.new(1, 0, 0, (density == "compact") and 26 or 30)
    header.BackgroundTransparency = 1
    header.TextColor3 = theme.text
    header.Font = Enum.Font.GothamBold
    header.TextSize = (density == "compact") and 16 or 18
    header.Parent = frame

    local selected = {}
    local defaultsSet = false
    if type(props.Default) == "table" then for _, v in ipairs(props.Default) do selected[#selected+1] = v end; defaultsSet = true end

    local panel = Instance.new("Frame")
    panel.Name = "Options"
    panel.Size = UDim2.new(1, 0, 0, 0)
    panel.AutomaticSize = Enum.AutomaticSize.Y
    panel.BackgroundTransparency = 1
    panel.Visible = false
    panel.Parent = frame
    local list = Instance.new("UIListLayout"); list.Parent = panel; list.Padding = UDim.new(0, (density == "compact") and 4 or 6); list.SortOrder = Enum.SortOrder.LayoutOrder

    header.MouseButton1Click:Connect(function()
        panel.Visible = not panel.Visible
        header.Text = (props.Name or "Dropdown") .. (panel.Visible and "  ▾" or "  ▸")
    end)

    for _, option in ipairs(props.Options or {}) do
        local optBtn = Instance.new("TextButton")
        optBtn.Text = tostring(option)
        optBtn.Size = UDim2.new(1, -8, 0, (density == "compact") and 24 or 28)
        optBtn.BackgroundColor3 = theme.dropdownOpt
        optBtn.TextColor3 = theme.text
        optBtn.Font = Enum.Font.Gotham
        optBtn.TextSize = (density == "compact") and 14 or 16
        optBtn.Parent = panel
        local btnCorner = Instance.new("UICorner"); btnCorner.CornerRadius = UDim.new(0, 6); btnCorner.Parent = optBtn
        if defaultsSet and table.find(selected, option) then optBtn.BackgroundColor3 = theme.buttonOn end
        optBtn.MouseButton1Click:Connect(function()
            if table.find(selected, option) then
                for idx, val in ipairs(selected) do if val == option then table.remove(selected, idx) break end end
                optBtn.BackgroundColor3 = theme.dropdownOpt
            else
                table.insert(selected, option)
                optBtn.BackgroundColor3 = theme.buttonOn
            end
            if props.Callback then props.Callback(selected) end
        end)
    end

    if defaultsSet and props.Callback then props.Callback(table.clone(selected)) end
    return frame
end

-- Single-select dropdown (library-agnostic)
function CustomGui:AddDropdown(parent, props)
    local frame = Instance.new("Frame")
    local theme = getThemeFor(parent)
    local sg = parent:FindFirstAncestorOfClass("ScreenGui")
    local density = sg and sg:GetAttribute("Density") or "comfortable"
    frame.Size = UDim2.new(0.98, 0, 0, 0)
    frame.AutomaticSize = Enum.AutomaticSize.Y
    frame.BackgroundColor3 = theme.dropdownBG
    frame.BackgroundTransparency = 0.18
    frame.ClipsDescendants = true
    frame.Parent = parent
    frame.LayoutOrder = parent:GetChildren() and #parent:GetChildren() or 1
    local uiCorner = Instance.new("UICorner"); uiCorner.CornerRadius = UDim.new(0, 8); uiCorner.Parent = frame
    local pad = Instance.new("UIPadding"); pad.PaddingLeft = UDim.new(0,4); pad.PaddingRight = UDim.new(0,4); pad.PaddingTop = UDim.new(0,6); pad.PaddingBottom = UDim.new(0,6); pad.Parent = frame
    local stack = Instance.new("UIListLayout"); stack.Parent = frame; stack.Padding = UDim.new(0, (density=="compact") and 4 or 6); stack.SortOrder = Enum.SortOrder.LayoutOrder

    local header = Instance.new("TextButton")
    header.Text = (props.Name or "Dropdown") .. "  ▾"
    header.Size = UDim2.new(1, 0, 0, (density == "compact") and 26 or 30)
    header.BackgroundTransparency = 1
    header.TextColor3 = theme.text
    header.Font = Enum.Font.GothamBold
    header.TextSize = (density == "compact") and 16 or 18
    header.Parent = frame

    local value = props.Default
    local panel = Instance.new("Frame")
    panel.Name = "Options"
    panel.Size = UDim2.new(1, 0, 0, 0)
    panel.AutomaticSize = Enum.AutomaticSize.Y
    panel.BackgroundTransparency = 1
    panel.Visible = false
    panel.Parent = frame
    local list = Instance.new("UIListLayout"); list.Parent = panel; list.Padding = UDim.new(0, (density == "compact") and 4 or 6); list.SortOrder = Enum.SortOrder.LayoutOrder

    header.MouseButton1Click:Connect(function()
        panel.Visible = not panel.Visible
        header.Text = (props.Name or "Dropdown") .. (panel.Visible and "  ▾" or "  ▸")
    end)

    for _, option in ipairs(props.Options or {}) do
        local optBtn = Instance.new("TextButton")
        optBtn.Text = tostring(option)
        optBtn.Size = UDim2.new(1, -8, 0, (density == "compact") and 24 or 28)
        optBtn.BackgroundColor3 = theme.dropdownOpt
        optBtn.TextColor3 = theme.text
        optBtn.Font = Enum.Font.Gotham
        optBtn.TextSize = (density == "compact") and 14 or 16
        optBtn.Parent = panel
        local btnCorner = Instance.new("UICorner"); btnCorner.CornerRadius = UDim.new(0, 6); btnCorner.Parent = optBtn
        if value == option then optBtn.BackgroundColor3 = theme.buttonOn end
        optBtn.MouseButton1Click:Connect(function()
            value = option
            for _, c in ipairs(panel:GetChildren()) do if c:IsA("TextButton") then c.BackgroundColor3 = theme.dropdownOpt end end
            optBtn.BackgroundColor3 = theme.buttonOn
            if props.Callback then props.Callback(value) end
            pcall(function() frame:SetAttribute("CG_Value", value) end)
            panel.Visible = false
            header.Text = (props.Name or "Dropdown") .. "  ▸"
        end)
    end

    pcall(function() frame:SetAttribute("CG_Value", value) end)
    if props.Default ~= nil and props.Callback then props.Callback(value) end
    return frame
end

-- Window helpers: theme switch, utilities, keybinds, command palette, ESP, noclip, click TP
do
    function CustomGui:_applyThemeToWindow(win, themeName)
        local theme = Themes[themeName] or Themes.Carbon
        local sg = win.ScreenGui
        if not sg then return end
        sg:SetAttribute("ThemeName", themeName)
        -- top-level frames
        if win.mainFrame then win.mainFrame.BackgroundColor3 = theme.bg end
        local topBar = win.mainFrame and win.mainFrame:FindFirstChild("TopBar")
        if topBar then topBar.BackgroundColor3 = theme.top end
        local tabBar = win.mainFrame and win.mainFrame:FindFirstChild("TabBar")
        if tabBar then tabBar.BackgroundColor3 = theme.tab end
        -- recolor tab buttons
        if tabBar then
            for _, child in ipairs(tabBar:GetChildren()) do
                if child:IsA("TextButton") then
                    child.TextColor3 = theme.text
                    -- keep active visually if its content visible
                    child.BackgroundColor3 = theme.tabInactive
                end
            end
        end
        -- recolor common controls in content
        for _, fr in ipairs(win.mainFrame and win.mainFrame:GetChildren() or {}) do
            if fr:IsA("ScrollingFrame") then
                for _, c in ipairs(fr:GetChildren()) do
                    if c:IsA("Frame") then
                        if c.Name == "Section" or c:FindFirstChildOfClass("TextLabel") then
                            pcall(function() c.BackgroundColor3 = theme.section end)
                        end
                    elseif c:IsA("TextButton") then
                        pcall(function() c.TextColor3 = theme.text end)
                    elseif c:IsA("TextLabel") then
                        pcall(function() c.TextColor3 = theme.text end)
                    end
                end
            end
        end
    end

    function CustomGui:_ensureKeybindLoop(win)
        if win._keybindConn then return end
        win._keybinds = win._keybinds or {}
        win._keybindConn = UIS.InputBegan:Connect(function(input, gp)
            if gp then return end
            if input.UserInputType == Enum.UserInputType.Keyboard then
                local list = win._keybinds[input.KeyCode]
                if list then for _, cb in ipairs(list) do pcall(cb) end end
            end
        end)
        win:RegisterTask("keybind-conn", win._keybindConn)
    end

    function CustomGui:_ensureCommandPalette(win, key)
        if win._cmdGui then return end
        local sg = Instance.new("ScreenGui")
        sg.Name = "CommandPalette"
        sg.IgnoreGuiInset = true
        sg.ResetOnSpawn = false
        sg.DisplayOrder = 1_000_001
        pcall(function() if Exec.protect_gui then Exec.protect_gui(sg) end end)
        sg.Parent = choose_ui_parent()
        local box = Instance.new("TextBox")
        box.Size = UDim2.new(0, 420, 0, 36)
        box.Position = UDim2.new(0.5, -210, 0.2, 0)
        local theme = getThemeFor(win.ScreenGui)
        box.BackgroundColor3 = theme.tab
        box.TextColor3 = theme.text
        box.PlaceholderText = "Type command (help)"
        box.Font = Enum.Font.Gotham
        box.TextSize = 18
        box.Parent = sg
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = box
        sg.Enabled = false
        win._cmdGui = sg
        win._cmdBox = box
        -- toggle key
        CustomGui:_ensureKeybindLoop(win)
        win:BindKey(key or Enum.KeyCode.F2, function()
            sg.Enabled = not sg.Enabled
            if sg.Enabled then box:CaptureFocus() end
        end)
        box.FocusLost:Connect(function(enter)
            if enter then
                local text = box.Text
                box.Text = ""
                sg.Enabled = false
                CustomGui:_execCommand(win, text)
            end
        end)
    end

    function CustomGui:_execCommand(win, text)
        text = (text or ""):lower()
        if text == "help" or text == "?" then
            Exec.notify("Commands", "stopall, antiafk on/off, theme carbon/midnight/pastel, rejoin, hop, fps <n>", 8)
            return
        end
        if text == "stopall" then win:StopAll(); return end
        if text:match("^antiafk ") then
            local arg = text:sub(8):gsub("%s+","")
            win:EnableAntiAFK(arg=="on" or arg=="true" or arg=="1")
            return
        end
        if text:match("^theme ") then
            local name = text:sub(7):gsub("%s+","")
            name = (name:gsub("^%l", string.upper))
            if Themes[name] then
                CustomGui:_applyThemeToWindow(win, name)
            else
                Exec.notify("Theme", "Unknown theme", 3)
            end
            return
        end
        if text == "rejoin" then pcall(function() TeleportService:Teleport(game.PlaceId, LocalPlayer) end); return end
        if text == "hop" or text == "serverhop" then CustomGui:_serverHop(); return end
        local n = tonumber(text:match("^fps%s+(%d+)$"))
        if n then CustomGui:_setFPS(n); return end
        Exec.notify("Command", "Unknown command", 2)
    end

    function CustomGui:_setFPS(n)
        local f = (setfpscap or set_fps_cap or setfps)
        if f then pcall(f, n) else Exec.notify("FPS", "Executor doesn’t support fps cap", 3) end
    end

    function CustomGui:_serverHop()
        local ok, err = pcall(function()
            local url = string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100", game.PlaceId)
            local body
            if http_request then
                local res = http_request({Url=url, Method="GET"})
                body = res and (res.Body or res.body)
            else
                body = game:HttpGet(url)
            end
            local data = HttpService:JSONDecode(body)
            for _, s in ipairs(data.data or {}) do
                if s.playing < s.maxPlayers and s.id ~= game.JobId then
                    TeleportService:TeleportToPlaceInstance(game.PlaceId, s.id)
                    return
                end
            end
            TeleportService:Teleport(game.PlaceId)
        end)
        if not ok then pcall(function() TeleportService:Teleport(game.PlaceId) end) end
    end

    function CustomGui:_toggleESP(win)
        local any = (win._esp and (win._esp.names or win._esp.highlight or win._esp.tracers)) and true or false
        if any and not win._espLoop then
            win._espData = win._espData or {}
            win._espLoop = win:RunLoop("esp-loop", function()
                for _, plr in ipairs(Players:GetPlayers()) do
                    if plr ~= LocalPlayer then
                        local char = plr.Character
                        if char then
                            -- Names (BillboardGui)
                            if win._esp.names then
                                local head = char:FindFirstChild("Head")
                                if head then
                                    local bb = head:FindFirstChild("_CG_Name")
                                    if not bb then
                                        bb = Instance.new("BillboardGui")
                                        bb.Name = "_CG_Name"
                                        bb.Size = UDim2.new(0, 0, 0, 0)
                                        bb.AlwaysOnTop = true
                                        bb.ExtentsOffset = Vector3.new(0, 2.5, 0)
                                        bb.Parent = head
                                        local tl = Instance.new("TextLabel")
                                        tl.Name = "Text"
                                        tl.BackgroundTransparency = 1
                                        tl.Size = UDim2.new(0, 200, 0, 20)
                                        tl.AnchorPoint = Vector2.new(0.5, 0.5)
                                        tl.Position = UDim2.new(0.5, 0, 0.5, 0)
                                        tl.TextScaled = true
                                        tl.Font = Enum.Font.GothamBold
                                        tl.Parent = bb
                                    end
                                    local tl = bb:FindFirstChild("Text")
                                    if tl then
                                        tl.Text = plr.DisplayName or plr.Name
                                        if win._esp.teamColors and plr.Team and plr.TeamColor then
                                            tl.TextColor3 = plr.TeamColor.Color
                                        else
                                            tl.TextColor3 = Color3.fromRGB(255,255,255)
                                        end
                                    end
                                end
                            else
                                local head = char:FindFirstChild("Head")
                                local bb = head and head:FindFirstChild("_CG_Name")
                                if bb then bb:Destroy() end
                            end
                            -- Highlight
                            if win._esp.highlight then
                                local hl = char:FindFirstChildOfClass("Highlight")
                                if not hl then
                                    hl = Instance.new("Highlight")
                                    hl.FillTransparency = 1
                                    hl.OutlineTransparency = 0
                                    hl.Parent = char
                                end
                                if win._esp.teamColors and plr.Team and plr.TeamColor then
                                    hl.OutlineColor = plr.TeamColor.Color
                                else
                                    hl.OutlineColor = Color3.fromRGB(255, 50, 50)
                                end
                            else
                                local hl = char:FindFirstChildOfClass("Highlight")
                                if hl then hl:Destroy() end
                            end
                            -- Tracers (Drawing API if available)
                            if win._esp.tracers and Drawing and typeof(Drawing.new) == "function" then
                                local cam = workspace.CurrentCamera
                                local root = char:FindFirstChild("HumanoidRootPart")
                                if root and cam then
                                    win._espData[plr] = win._espData[plr] or {}
                                    local line = win._espData[plr].line
                                    if not line then
                                        line = Drawing.new("Line")
                                        line.Thickness = 1.5
                                        line.Transparency = 1
                                        win._espData[plr].line = line
                                    end
                                    local from = Vector2.new(cam.ViewportSize.X/2, cam.ViewportSize.Y)
                                    local pos, onScreen = cam:WorldToViewportPoint(root.Position)
                                    if onScreen then
                                        line.Visible = true
                                        line.From = from
                                        line.To = Vector2.new(pos.X, pos.Y)
                                        line.Color = (win._esp.teamColors and plr.Team and plr.TeamColor and plr.TeamColor.Color) or Color3.fromRGB(255, 255, 255)
                                    else
                                        line.Visible = false
                                    end
                                end
                            else
                                -- destroy tracer if exists
                                local d = win._espData and win._espData[plr]
                                if d and d.line and d.line.Remove then pcall(function() d.line:Remove() end) end
                                if d then d.line = nil end
                            end
                        end
                    end
                end
            end, 0.25)
        elseif (not any) and win._espLoop then
            pcall(win._espLoop) -- stop function
            win._espLoop = nil
            -- cleanup adornments
            for _, plr in ipairs(Players:GetPlayers()) do
                if plr ~= LocalPlayer and plr.Character then
                    local head = plr.Character:FindFirstChild("Head")
                    local bb = head and head:FindFirstChild("_CG_Name")
                    if bb then bb:Destroy() end
                    local hl = plr.Character:FindFirstChildOfClass("Highlight")
                    if hl then hl:Destroy() end
                end
            end
            if win._espData then
                for _, d in pairs(win._espData) do
                    if d.line and d.line.Remove then pcall(function() d.line:Remove() end) end
                end
                win._espData = {}
            end
        end
    end

    function CustomGui:_enableNoclip(win, state)
        state = not not state
        if state and not win._noclipConn then
            win._noclipConn = RunService.Stepped:Connect(function()
                local char = LocalPlayer.Character
                if not char then return end
                for _, p in ipairs(char:GetDescendants()) do
                    if p:IsA("BasePart") then p.CanCollide = false end
                end
            end)
            win:RegisterTask("noclip", win._noclipConn)
        elseif (not state) and win._noclipConn then
            pcall(function() win._noclipConn:Disconnect() end)
            win._noclipConn = nil
        end
    end

    function CustomGui:_enableClickTP(win, state, modifierKey)
        state = not not state
        win._clickTPMod = modifierKey or Enum.KeyCode.LeftControl
        if state and not win._clickTPConn then
            local mouse = LocalPlayer:GetMouse()
            win._clickTPConn = mouse.Button1Down:Connect(function()
                if not UIS:IsKeyDown(win._clickTPMod) then return end
                local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not hrp then return end
                local pos = mouse.Hit and mouse.Hit.p
                if pos then
                    hrp.CFrame = CFrame.new(pos + Vector3.new(0, 3, 0))
                end
            end)
            win:RegisterTask("clicktp", win._clickTPConn)
        elseif (not state) and win._clickTPConn then
            pcall(function() win._clickTPConn:Disconnect() end)
            win._clickTPConn = nil
        end
    end

    function CustomGui:_buildUtilitiesTab(win)
        local tab = win:MakeTab({ Name = "Utilities" })
        -- Persistent Utilities store
        win._utilitiesStore = win._utilitiesStore or win:CreateStore("utilities")
        local uStore = win._utilitiesStore
        local defaults = {
            antiAFK = false,
            espNames = false,
            espHighlight = false,
            espTracers = false,
            espTeamColors = true,
            noclip = false,
            clickTP = false,
            fpsCap = 60,
            theme = "Carbon",
        }
        local uSettings = uStore:Get("utilities", defaults)
        local function usave() uStore:Set("utilities", uSettings) end

        -- Anti-AFK
        CustomGui:AddToggle(tab, { Name = "Anti-AFK", Default = uSettings.antiAFK, Callback = function(on)
            uSettings.antiAFK = on; usave(); win:EnableAntiAFK(on)
        end })

        -- ESP toggles
        win._esp = win._esp or { names=false, highlight=false, tracers=false, teamColors=true }
        win._esp.names = uSettings.espNames
        win._esp.highlight = uSettings.espHighlight
        win._esp.tracers = uSettings.espTracers
        win._esp.teamColors = uSettings.espTeamColors
        CustomGui:AddToggle(tab, { Name = "ESP Names", Default = uSettings.espNames, Callback = function(on)
            uSettings.espNames = on; usave(); win._esp.names = on; CustomGui:_toggleESP(win)
        end })
        CustomGui:AddToggle(tab, { Name = "ESP Highlight", Default = uSettings.espHighlight, Callback = function(on)
            uSettings.espHighlight = on; usave(); win._esp.highlight = on; CustomGui:_toggleESP(win)
        end })
        local drawingAvail = (Drawing and typeof(Drawing.new) == "function")
        CustomGui:AddToggle(tab, { Name = "ESP Tracers" .. (drawingAvail and "" or " (Unavailable)"), Default = uSettings.espTracers, Callback = function(on)
            if drawingAvail then uSettings.espTracers = on; usave(); win._esp.tracers = on; CustomGui:_toggleESP(win) else Exec.notify("ESP", "Drawing API not available", 3) end
        end })
        CustomGui:AddToggle(tab, { Name = "ESP Team Colors", Default = uSettings.espTeamColors, Callback = function(on)
            uSettings.espTeamColors = on; usave(); win._esp.teamColors = on; CustomGui:_toggleESP(win)
        end })

        -- Noclip & Click TP
        CustomGui:AddToggle(tab, { Name = "Noclip", Default = uSettings.noclip, Callback = function(on)
            uSettings.noclip = on; usave(); CustomGui:_enableNoclip(win, on)
        end })
        CustomGui:AddToggle(tab, { Name = "Click TP (Hold Ctrl)", Default = uSettings.clickTP, Callback = function(on)
            uSettings.clickTP = on; usave(); CustomGui:_enableClickTP(win, on, Enum.KeyCode.LeftControl)
        end })

        -- FPS Cap
        CustomGui:AddSlider(tab, { Name = "FPS Cap", Min = 30, Max = 360, Default = uSettings.fpsCap or 60, Callback = function(v)
            v = math.floor(v)
            uSettings.fpsCap = v; usave(); CustomGui:_setFPS(v)
        end })

        -- Server actions
        CustomGui:AddButton(tab, { Name = "Rejoin", Callback = function()
            pcall(function() TeleportService:Teleport(game.PlaceId, LocalPlayer) end)
        end })
        CustomGui:AddButton(tab, { Name = "Server Hop", Callback = function()
            CustomGui:_serverHop()
        end })

        -- Theme as dropdown
        CustomGui:AddLabel(tab, "Theme")
        CustomGui:AddDropdown(tab, {
            Name = "Theme",
            Options = {"Carbon", "Midnight", "Pastel"},
            Default = uSettings.theme or "Carbon",
            Callback = function(val)
                uSettings.theme = val; usave(); CustomGui:_applyThemeToWindow(win, val)
            end
        })
        CustomGui:_applyThemeToWindow(win, uSettings.theme or "Carbon")

        -- Keybinds & Command palette
        CustomGui:_ensureKeybindLoop(win)
        CustomGui:_ensureCommandPalette(win, Enum.KeyCode.F2)
        return tab
    end

    -- Public window APIs
    function CustomGui:BuildUtilitiesTab(win)
        return CustomGui:_buildUtilitiesTab(win)
    end

    function CustomGui:SetTheme(win, name)
        CustomGui:_applyThemeToWindow(win, name)
    end

    function CustomGui:BindKey(win, keyCode, cb)
        CustomGui:_ensureKeybindLoop(win)
        win._keybinds[keyCode] = win._keybinds[keyCode] or {}
        table.insert(win._keybinds[keyCode], cb)
        return function()
            local t = win._keybinds[keyCode]
            if not t then return end
            for i, f in ipairs(t) do if f == cb then table.remove(t, i) break end end
        end
    end
end

return CustomGui
